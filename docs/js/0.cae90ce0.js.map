{"version":3,"sources":["webpack:///./node_modules/glsl-parser/parser.js"],"names":["__extends","derived","base","prototype","Object","create","constructor","__imul","Math","imul","a","b","__isString","value","assert","truth","Error","GLSLX","RenameSymbols","ALL","CompilerOptions","this","compactSyntaxTree","removeWhitespace","renameSymbols","trimSymbols","fileAccess","globals","ExtensionBehavior","DEFAULT","DISABLE","ENABLE","REQUIRE","WARN","CompilerData","currentExtensions","_nextSymbolID","nextSymbolID","extensionBehavior","name","in_StringMap","get","Compiler","typeCheck","log","sources","options","hasErrors","unshift","Source","API","i","list","count","length","source","in_List","tokens","Tokenizer","tokenize","global","Node","NodeKind","GLOBAL","scope","Scope","ScopeKind","data","resolver","Resolver","i1","list1","count1","source1","Parser","parse","resolveGlobal","ControlFlowAnalyzer","_isLoopBreakTarget","_isControlFlowLive","pushBlock","node","parent","push","last","in_NodeKind","isLoop","kind","popBlock","isLive","takeLast","hasControlFlowAtEnd","WHILE","whileTest","isTrue","DO_WHILE","doWhileTest","FOR","forTest","setLast","visitStatement","BREAK","RETURN","DISCARD","CONTINUE","IF","test","ifTest","trueValue","ifTrue","falseValue","ifFalse","isFalse","Folder","fold","RELEASE","_fold","folded","UNKNOWN_CONSTANT","_check","INT","resolvedType","Type","hasChildren","BOOL","FLOAT","CALL","target","callTarget","TYPE","componentType","componentCount","childCount","child","nextSibling","struct","symbol","asStruct","variables","child1","type","ERROR","clone","NAME","_foldName","SEQUENCE","_foldSequence","HOOK","_foldHook","DOT","_foldDot","INDEX","_foldIndex","_foldCall","NEGATIVE","_foldUnaryFloatOrInt","x","NOT","_foldUnaryBool","POSITIVE","ADD","_foldBinaryFloatOrInt","SUBTRACT","MULTIPLY","_foldMultiply","DIVIDE","EQUAL","NOT_EQUAL","_foldBinaryEquality","LOGICAL_AND","_foldBinaryBool","LOGICAL_OR","LOGICAL_XOR","GREATER_THAN","_foldBinaryFloatOrIntToBool","GREATER_THAN_OR_EQUAL","LESS_THAN","LESS_THAN_OR_EQUAL","isConst","constantValue","asVariable","VariableKind","ARGUMENT","withType","firstChild","lastChild","foldedTest","hookTest","foldedTrue","hookTrue","foldedFalse","hookFalse","asBool","dotTarget","asString","isVector","i2","Swizzle","strings","count2","set","indexOf","in_string","childAt","remove","swizzleType","result","createConstructorCall","appendChild","isStruct","count3","variable","foldedLeft","binaryLeft","foldedRight","binaryRight","indexCount","index","asInt","isMatrix","indexCount1","index1","indexType","before","matrixStride","$arguments","casted","_castValue","_foldComponentConstructor","_foldStruct","_floatValues","values","asFloat","ref","left","right","leftType","rightType","VEC2","MAT2","VEC3","MAT3","VEC4","MAT4","stride","leftValues","rightValues","total","col","withFloat","stride1","result1","leftValues1","rightValues1","total1","row","stride2","result2","leftValues2","rightValues2","row1","count6","col1","count5","total2","count4","_foldFloat2","_foldInt2","withBool","withInt","argument","first","isOffMatrixDiagonal","argument1","looksTheSameAs","_foldComponentwiseUnary","argumentKind","op","_foldFloat1","_foldInt1","_foldComponentwiseBinary","leftHasComponents","rightHasComponents","leftChild","rightChild","folded1","unaryValue","floatOp","intOp","DiagnosticKind","WARNING","Diagnostic","range","text","noteRange","noteText","Log","diagnostics","warningCount","errorCount","error","warning","note","syntaxWarningUnknownExtension","syntaxErrorInvalidString","syntaxErrorDisabledExtension","extension","syntaxErrorExtraData","syntaxErrorReservedWord","toString","syntaxErrorUnexpectedToken","token","in_TokenKind","_strings","syntaxErrorExpectedToken1","expected","syntaxErrorExpectedToken2","found","syntaxErrorBadSymbolReference","syntaxErrorDuplicateSymbolDefinition","previous","syntaxErrorOutsideLoop","syntaxErrorStructVariableInitializer","syntaxErrorInsideStruct","syntaxErrorInsideFunction","syntaxErrorOutsideFunction","semanticErrorIncludeWithoutFileAccess","semanticErrorIncludeBadPath","path","JSON","stringify","syntaxErrorDifferentReturnType","syntaxErrorBadQualifier","syntaxErrorConstantRequired","syntaxErrorInvalidArraySize","syntaxErrorMissingArraySize","syntaxErrorMultidimensionalArray","syntaxErrorInvalidOperator","semanticErrorBadConversion","from","to","semanticErrorUnexpectedType","semanticErrorBadVariableType","semanticErrorBadMember","semanticErrorBadSwizzle","semanticErrorBadSwizzleAssignment","field","semanticErrorMustCallFunction","semanticErrorBadCall","semanticErrorBadConstructorValue","$constructor","semanticErrorExtraConstructorValue","semanticErrorBadConstructorCount","semanticErrorArgumentCountFunction","$function","semanticErrorArgumentCountConstructor","semanticErrorBadOverloadMatch","semanticErrorBadHookTypes","semanticErrorArrayHook","isArrayOf","semanticErrorArrayAssignment","semanticErrorBadUnaryOperator","operator","semanticErrorBadBinaryOperator","semanticErrorBadIndex","semanticErrorOutOfBoundsIndex","semanticErrorBadStorage","semanticErrorUninitializedConstant","semanticErrorMissingReturn","semanticErrorBadMatrixConstructor","STRUCT_BLOCK","VARIABLE","BLOCK","EXPRESSION","EXTENSION","FUNCTION","MODIFIER_BLOCK","PRECISION","STRUCT","VARIABLES","VERSION","PARSE_ERROR","PREFIX_DECREMENT","PREFIX_INCREMENT","POSTFIX_DECREMENT","POSTFIX_INCREMENT","ASSIGN","ASSIGN_ADD","ASSIGN_DIVIDE","ASSIGN_MULTIPLY","ASSIGN_SUBTRACT","id","_createID","internalRange","_literal","_text","_parent","_firstChild","_lastChild","_previousSibling","_nextSibling","_copyMembersFrom","cloneWithoutChildren","withSymbol","withText","withRange","withInternalRange","insertChildBefore","after","isCallTarget","isAssignTarget","isUnaryAssign","isBinaryAssign","isEmptySequence","isUnary","isBinary","createDoWhile","body","isStatement","isExpression","createExpression","createFor","setup","update","createIf","yes","no","createPrecision","flags","createReturn","createStruct","block","createVariables","createWhile","createCall","createDot","createHook","createUnary","createBinary","doWhileBody","expressionValue","forSetup","forUpdate","forBody","returnValue","variablesType","whileBody","_nextID","typeParselet","context","unaryPrefix","isUnaryPrefix","Range","span","unaryPostfix","isUnaryPostfix","binaryParselet","parseInt","get1","createExpressionParser","pratt","Pratt","invalidUnaryOperator","invalidBinaryOperator","literal","TokenKind","TRUE","FALSE","INT_LITERAL","FLOAT_LITERAL","BVEC2","BVEC3","BVEC4","IVEC2","IVEC3","IVEC4","VOID","prefix","COMPLEMENT","Precedence","UNARY_PREFIX","DECREMENT","INCREMENT","MINUS","PLUS","postfix","UNARY_POSTFIX","infix","COMPARE","REMAINDER","SHIFT_LEFT","SHIFT","SHIFT_RIGHT","BITWISE_AND","BITWISE_OR","BITWISE_XOR","infixRight","ASSIGN_BITWISE_AND","ASSIGN_BITWISE_OR","ASSIGN_BITWISE_XOR","ASSIGN_REMAINDER","ASSIGN_SHIFT_LEFT","ASSIGN_SHIFT_RIGHT","IDENTIFIER","find","requiredExtension","compilationData","COMMA","spanSince","parselet","MEMBER","next","current","expect","LEFT_PARENTHESIS","LOWEST","RIGHT_PARENTHESIS","parseCommaSeparatedList","LEFT_BRACKET","peek","RIGHT_BRACKET","unexpectedToken","QUESTION","middle","COLON","stop","isFirst","eat","parseDoWhile","pushScope","LOOP","parseStatement","LOCAL","popScope","checkForSemicolon","parseExportOrImport","old","EXPORT","SymbolFlags","EXPORTED","IMPORTED","LEFT_BRACE","parseStatements","RIGHT_BRACE","statement","parseExtension","_knownWebGLExtensions","_extensionBehaviors","behavior","parseFor","SEMICOLON","parseFlags","parseType","ParseTypeMode","REPORT_ERRORS","IGNORE_ERRORS","parseAfterType","Allow","AVOID_FUNCTIONS","parseIf","ELSE","parseVersion","parseWhile","parseReturn","parsePrecision","flag","LOWP","MEDIUMP","HIGHP","parseStruct","StructSymbol","tryToDefineUniquelyInScope","END_OF_FILE","parseVariables","checkForLoopAndSemicolon","allow","resume","parseFunction","mode","DO","IMPORT","parseBlock","ALLOW_FUNCTIONS","checkStatementLocation","isOutsideFunction","shouldBeOutsideFunction","parseInclude","STRING_LITERAL","e","nestedContext","ParserContext","ATTRIBUTE","CONST","IN","INOUT","OUT","UNIFORM","VARYING","SAMPLER2D","SAMPLERCUBE","originalScope","FunctionSymbol","returnType","argumentFlags","argumentType","argumentName","VariableSymbol","parseArraySize","symbols","hasBlock","define","isFunction","link","asFunction","previousOverload","hasSameArgumentTypesAs","sibling","redefine","arrayCount","resolveNode","checkConversion","arrayType","assign","INCLUDE","_tokens","_index","_scope","end","start","lineColumn","line","rangeAtEnd","newScope","Parselet","precedence","_table","in_IntMap","created","callback","self","slice2","contents","slice","offsetStart","offsetEnd","indexToLineColumn","_log","_data","_controlFlow","_versions","_generatedExtensions","_returnType","version","_resolveChildren","_resolveAsExpression","containsArray","_resolveBlockOrStatement","symbol1","type1","containsSampler","_resolveCall","_resolveDot","symbol2","isVariable","_resolveUnary","_resolveBinary","_checkStorage","valueType","isIntOrFloat","isSame","hasFloatComponents","hasIntComponents","canUseEqualityOperators","hasError","_resolveFunctionOverloads","_resolveConstructor","_validateSwizzle","overloaded","overloads","overload","removeIf","overloadsBeforeTypeFilter","fromSize","toSize","overload1","variableCount","argumentCount","hasMatrixArgument","providedCount","deltaCount","isMatrixMatrixConstructor","n","label","LineColumn","column","_lineOffsets","_computeLineOffsets","step","_STRINGS_2","_STRINGS_3","_STRINGS_4","comonentType","Symbol","_resolvedType","call","INVARIANT","Token","parts","split","_tokenRegex","part","c","keyword","keywords","reservedWords","_intRegex","operators","_arrayTypes","_setContainsSampler","Exports","sourcesFromInput","input","Array","main","root","exports","check","args","disableRewriting","prettyPrint","keepSymbols","charCodeAt","removeLast","pop","key","insert","defaultValue","RegExp"],"mappings":"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","file":"js/0.cae90ce0.js","sourcesContent":["(function() {\n  function __extends(derived, base) {\n    derived.prototype = Object.create(base.prototype);\n    derived.prototype.constructor = derived;\n  }\n\n  var __imul = Math.imul ? Math.imul : function(a, b) {\n    return (a * (b >>> 16) << 16) + a * (b & 65535) | 0;\n  };\n\n  function __isString(value) {\n    return typeof value === 'string';\n  }\n\n  function assert(truth) {\n    if (!truth) {\n      throw Error('Assertion failed');\n    }\n  }\n\n  var GLSLX = {};\n\n  GLSLX.RenameSymbols = {\n    ALL: 0\n  };\n\n  GLSLX.CompilerOptions = function() {\n    this.compactSyntaxTree = true;\n    this.removeWhitespace = true;\n    this.renameSymbols = GLSLX.RenameSymbols.ALL;\n    this.trimSymbols = true;\n    this.fileAccess = null;\n    this.globals = null;\n  };\n\n  GLSLX.ExtensionBehavior = {\n    DEFAULT: 0,\n    DISABLE: 1,\n    ENABLE: 2,\n    REQUIRE: 3,\n    WARN: 4\n  };\n\n  GLSLX.CompilerData = function(fileAccess) {\n    this.currentExtensions = Object.create(null);\n    this.fileAccess = fileAccess;\n    this._nextSymbolID = 0;\n  };\n\n  GLSLX.CompilerData.prototype.nextSymbolID = function() {\n    this._nextSymbolID = this._nextSymbolID + 1 | 0;\n    return this._nextSymbolID;\n  };\n\n  GLSLX.CompilerData.prototype.extensionBehavior = function(name) {\n    return in_StringMap.get(this.currentExtensions, name, GLSLX.ExtensionBehavior.DEFAULT);\n  };\n\n  GLSLX.Compiler = {};\n\n  GLSLX.Compiler.typeCheck = function(log, sources, options) {\n    if (log.hasErrors()) {\n      return null;\n    }\n\n    // Generate tokens once\n    sources.unshift(new GLSLX.Source('<api>', GLSLX.API));\n\n    if (options.globals != null) {\n      sources.unshift(new GLSLX.Source('<externs_globals>', options.globals));\n    }\n\n    for (var i = 0, list = sources, count = list.length; i < count; i = i + 1 | 0) {\n      var source = in_List.get(list, i);\n      source.tokens = GLSLX.Tokenizer.tokenize(log, source);\n    }\n\n    var global = new GLSLX.Node(GLSLX.NodeKind.GLOBAL);\n    var scope = new GLSLX.Scope(GLSLX.ScopeKind.GLOBAL, null);\n    var data = new GLSLX.CompilerData(options.fileAccess);\n    var resolver = new GLSLX.Resolver(log, data);\n\n    // Parse everything next\n    for (var i1 = 0, list1 = sources, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\n      var source1 = in_List.get(list1, i1);\n      GLSLX.Parser.parse(log, source1.tokens, global, data, scope, resolver);\n    }\n\n    // Then run type checking\n    resolver.resolveGlobal(global);\n\n    // Always return even when there were errors since the partial result is still useful\n    return global;\n  };\n\n  GLSLX.ControlFlowAnalyzer = function() {\n    this._isLoopBreakTarget = [];\n    this._isControlFlowLive = [];\n  };\n\n  GLSLX.ControlFlowAnalyzer.prototype.pushBlock = function(node) {\n    var parent = node.parent();\n\n    // Push control flow\n    this._isControlFlowLive.push(this._isControlFlowLive.length == 0 || in_List.last(this._isControlFlowLive));\n\n    // Push loop info\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind)) {\n      this._isLoopBreakTarget.push(false);\n    }\n  };\n\n  GLSLX.ControlFlowAnalyzer.prototype.popBlock = function(node) {\n    var parent = node.parent();\n\n    // Pop control flow\n    var isLive = in_List.takeLast(this._isControlFlowLive);\n\n    if (isLive) {\n      node.hasControlFlowAtEnd = true;\n    }\n\n    // Pop loop info\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind) && !in_List.takeLast(this._isLoopBreakTarget) && (parent.kind == GLSLX.NodeKind.WHILE && parent.whileTest().isTrue() || parent.kind == GLSLX.NodeKind.DO_WHILE && parent.doWhileTest().isTrue() || parent.kind == GLSLX.NodeKind.FOR && (parent.forTest() == null || parent.forTest().isTrue()))) {\n      in_List.setLast(this._isControlFlowLive, false);\n    }\n  };\n\n  GLSLX.ControlFlowAnalyzer.prototype.visitStatement = function(node) {\n    if (!in_List.last(this._isControlFlowLive)) {\n      return;\n    }\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.BREAK: {\n        if (!(this._isLoopBreakTarget.length == 0)) {\n          in_List.setLast(this._isLoopBreakTarget, true);\n        }\n\n        in_List.setLast(this._isControlFlowLive, false);\n        break;\n      }\n\n      case GLSLX.NodeKind.RETURN:\n      case GLSLX.NodeKind.DISCARD:\n      case GLSLX.NodeKind.CONTINUE: {\n        in_List.setLast(this._isControlFlowLive, false);\n        break;\n      }\n\n      case GLSLX.NodeKind.IF: {\n        var test = node.ifTest();\n        var trueValue = node.ifTrue();\n        var falseValue = node.ifFalse();\n\n        if (test.isTrue()) {\n          if (!trueValue.hasControlFlowAtEnd) {\n            in_List.setLast(this._isControlFlowLive, false);\n          }\n        }\n\n        else if (test.isFalse() && falseValue != null) {\n          if (!falseValue.hasControlFlowAtEnd) {\n            in_List.setLast(this._isControlFlowLive, false);\n          }\n        }\n\n        else if (trueValue != null && falseValue != null) {\n          if (!trueValue.hasControlFlowAtEnd && !falseValue.hasControlFlowAtEnd) {\n            in_List.setLast(this._isControlFlowLive, false);\n          }\n        }\n        break;\n      }\n    }\n  };\n\n  GLSLX.Folder = {};\n\n  GLSLX.Folder.fold = function(node) {\n    if (RELEASE) {\n      return GLSLX.Folder._fold(node);\n    }\n\n    // Run sanity checks in debug mode\n    else {\n      var folded = GLSLX.Folder._fold(node);\n\n      if (folded != null) {\n        assert(folded.parent() == null);\n\n        if (folded.kind != GLSLX.NodeKind.UNKNOWN_CONSTANT) {\n          GLSLX.Folder._check(folded);\n        }\n      }\n\n      return folded;\n    }\n  };\n\n  GLSLX.Folder._check = function(node) {\n    switch (node.kind) {\n      case GLSLX.NodeKind.INT: {\n        assert(node.resolvedType == GLSLX.Type.INT && !node.hasChildren());\n        break;\n      }\n\n      case GLSLX.NodeKind.BOOL: {\n        assert(node.resolvedType == GLSLX.Type.BOOL && !node.hasChildren());\n        break;\n      }\n\n      case GLSLX.NodeKind.FLOAT: {\n        assert(node.resolvedType == GLSLX.Type.FLOAT && !node.hasChildren());\n        break;\n      }\n\n      case GLSLX.NodeKind.CALL: {\n        var target = node.callTarget();\n        assert(target.kind == GLSLX.NodeKind.TYPE);\n        assert(target.resolvedType == node.resolvedType);\n        var componentType = target.resolvedType.componentType();\n        var componentCount = target.resolvedType.componentCount();\n\n        // Native component types\n        if (componentType != null) {\n          assert(node.childCount() == (1 + componentCount | 0));\n          assert(target.resolvedType != GLSLX.Type.INT && target.resolvedType != GLSLX.Type.BOOL && target.resolvedType != GLSLX.Type.FLOAT);\n\n          for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\n            assert(child.resolvedType == componentType);\n            assert(child.kind != GLSLX.NodeKind.CALL);\n            GLSLX.Folder._check(child);\n          }\n        }\n\n        // User-defined structs\n        else {\n          var struct = target.resolvedType.symbol.asStruct();\n          var i = 0;\n          assert(node.childCount() == (1 + struct.variables.length | 0));\n\n          for (var child1 = target.nextSibling(); child1 != null; child1 = child1.nextSibling()) {\n            assert(child1.resolvedType == in_List.get(struct.variables, i).type.resolvedType);\n            GLSLX.Folder._check(child1);\n            i = i + 1 | 0;\n          }\n        }\n        break;\n      }\n\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  };\n\n  GLSLX.Folder._fold = function(node) {\n    assert(node.resolvedType != null);\n\n    if (node.resolvedType == GLSLX.Type.ERROR) {\n      return null;\n    }\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.INT:\n      case GLSLX.NodeKind.FLOAT:\n      case GLSLX.NodeKind.BOOL: {\n        return node.clone();\n      }\n\n      case GLSLX.NodeKind.NAME: {\n        return GLSLX.Folder._foldName(node);\n      }\n\n      case GLSLX.NodeKind.SEQUENCE: {\n        return GLSLX.Folder._foldSequence(node);\n      }\n\n      case GLSLX.NodeKind.HOOK: {\n        return GLSLX.Folder._foldHook(node);\n      }\n\n      case GLSLX.NodeKind.DOT: {\n        return GLSLX.Folder._foldDot(node);\n      }\n\n      case GLSLX.NodeKind.INDEX: {\n        return GLSLX.Folder._foldIndex(node);\n      }\n\n      case GLSLX.NodeKind.CALL: {\n        return GLSLX.Folder._foldCall(node);\n      }\n\n      case GLSLX.NodeKind.NEGATIVE: {\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\n          return -x;\n        }, function(x) {\n          return -x | 0;\n        });\n      }\n\n      case GLSLX.NodeKind.NOT: {\n        return GLSLX.Folder._foldUnaryBool(node, function(x) {\n          return !x;\n        });\n      }\n\n      case GLSLX.NodeKind.POSITIVE: {\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\n          return +x;\n        }, function(x) {\n          return +x;\n        });\n      }\n\n      case GLSLX.NodeKind.ADD: {\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\n          return a + b;\n        }, function(a, b) {\n          return a + b | 0;\n        });\n      }\n\n      case GLSLX.NodeKind.SUBTRACT: {\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\n          return a - b;\n        }, function(a, b) {\n          return a - b | 0;\n        });\n      }\n\n      case GLSLX.NodeKind.MULTIPLY: {\n        return GLSLX.Folder._foldMultiply(node);\n      }\n\n      case GLSLX.NodeKind.DIVIDE: {\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\n          return b != 0 ? a / b : 0;\n        }, function(a, b) {\n          return b != 0 ? a / b | 0 : 0;\n        });\n      }\n\n      case GLSLX.NodeKind.EQUAL:\n      case GLSLX.NodeKind.NOT_EQUAL: {\n        return GLSLX.Folder._foldBinaryEquality(node);\n      }\n\n      case GLSLX.NodeKind.LOGICAL_AND: {\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\n          return a && b;\n        });\n      }\n\n      case GLSLX.NodeKind.LOGICAL_OR: {\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\n          return a || b;\n        });\n      }\n\n      case GLSLX.NodeKind.LOGICAL_XOR: {\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\n          return a != b;\n        });\n      }\n\n      case GLSLX.NodeKind.GREATER_THAN: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a > b;\n        });\n      }\n\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a >= b;\n        });\n      }\n\n      case GLSLX.NodeKind.LESS_THAN: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a < b;\n        });\n      }\n\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a <= b;\n        });\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldName = function(node) {\n    var symbol = node.symbol;\n\n    if (symbol != null && symbol.isConst()) {\n      if (symbol.constantValue != null) {\n        return symbol.constantValue.clone();\n      }\n\n      if (symbol.asVariable().kind != GLSLX.VariableKind.ARGUMENT) {\n        return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(node.resolvedType);\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldSequence = function(node) {\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n      var folded = GLSLX.Folder.fold(child);\n\n      if (folded == null || child == node.lastChild()) {\n        return folded;\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldHook = function(node) {\n    var foldedTest = GLSLX.Folder.fold(node.hookTest());\n    var foldedTrue = GLSLX.Folder.fold(node.hookTrue());\n    var foldedFalse = GLSLX.Folder.fold(node.hookFalse());\n\n    if (foldedTest != null && foldedTest.kind == GLSLX.NodeKind.BOOL && foldedTrue != null && foldedFalse != null) {\n      return foldedTest.asBool() ? foldedTrue : foldedFalse;\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldDot = function(node) {\n    var folded = GLSLX.Folder.fold(node.dotTarget());\n\n    if (folded != null && folded.kind == GLSLX.NodeKind.CALL) {\n      var resolvedType = folded.resolvedType;\n      var name = node.asString();\n\n      // Evaluate a swizzle\n      if (resolvedType.isVector()) {\n        var count = name.length;\n        var componentCount = resolvedType.componentCount();\n\n        // Find the swizzle set\n        for (var i2 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i2 < count2; i2 = i2 + 1 | 0) {\n          var set = in_List.get(list, i2);\n\n          if (set.indexOf(in_string.get(name, 0)) != -1) {\n            if (count == 1) {\n              return folded.childAt(1 + set.indexOf(name) | 0).remove();\n            }\n\n            var swizzleType = GLSLX.Swizzle.type(resolvedType.componentType(), count);\n            var result = GLSLX.Node.createConstructorCall(swizzleType);\n\n            for (var i = 0, count1 = count; i < count1; i = i + 1 | 0) {\n              result.appendChild(folded.childAt(1 + set.indexOf(in_string.get(name, i)) | 0).clone());\n            }\n\n            return result;\n          }\n        }\n      }\n\n      // Evaluate a struct field\n      else if (resolvedType.symbol != null && resolvedType.symbol.isStruct()) {\n        var symbol = resolvedType.symbol.asStruct();\n        var variables = symbol.variables;\n        assert(folded.childCount() == (1 + variables.length | 0));\n\n        // Extract the field from the constructor call\n        for (var i1 = 0, count3 = variables.length; i1 < count3; i1 = i1 + 1 | 0) {\n          var variable = in_List.get(variables, i1);\n\n          if (variable.name == name) {\n            return folded.childAt(1 + i1 | 0).remove();\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldIndex = function(node) {\n    var foldedLeft = GLSLX.Folder.fold(node.binaryLeft());\n    var foldedRight = GLSLX.Folder.fold(node.binaryRight());\n\n    // Both children must also be constants\n    if (foldedLeft != null && foldedLeft.kind == GLSLX.NodeKind.CALL && foldedRight != null && foldedRight.kind == GLSLX.NodeKind.INT) {\n      var type = foldedLeft.resolvedType;\n\n      if (type.isVector()) {\n        var indexCount = type.indexCount();\n        var index = foldedRight.asInt();\n\n        // The index must be in range\n        if (0 <= index && index < indexCount) {\n          return foldedLeft.childAt(index + 1 | 0).remove();\n        }\n      }\n\n      // Indexing into a matrix creates a vector\n      else if (type.isMatrix()) {\n        var indexCount1 = type.indexCount();\n        var index1 = foldedRight.asInt();\n        assert(foldedLeft.childCount() == (1 + __imul(indexCount1, indexCount1) | 0));\n\n        // The index must be in range\n        if (0 <= index1 && index1 < indexCount1) {\n          var indexType = type.indexType();\n          var result = GLSLX.Node.createConstructorCall(indexType);\n          var before = foldedLeft.childAt(__imul(index1, indexCount1));\n\n          for (var i = 0, count = indexCount1; i < count; i = i + 1 | 0) {\n            result.appendChild(before.nextSibling().remove());\n          }\n\n          return result;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldCall = function(node) {\n    var target = node.callTarget();\n\n    // Only constructor calls are considered constants\n    if (target.kind != GLSLX.NodeKind.TYPE) {\n      return null;\n    }\n\n    var type = target.resolvedType;\n    var componentType = type.componentType();\n    var matrixStride = 0;\n    var $arguments = [];\n    var count = 0;\n\n    // Make sure all arguments are constants\n    for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\n      var folded = GLSLX.Folder.fold(child);\n\n      if (folded == null) {\n        return null;\n      }\n\n      // Expand values inline from constructed native types\n      if (folded.kind == GLSLX.NodeKind.CALL && componentType != null && folded.callTarget().resolvedType.componentType() != null) {\n        for (var value = folded.callTarget().nextSibling(); value != null; value = value.nextSibling()) {\n          var casted = GLSLX.Folder._castValue(componentType, value);\n\n          if (casted == null) {\n            return null;\n          }\n\n          $arguments.push(casted);\n        }\n      }\n\n      // Auto-cast values for primitive types\n      else {\n        if (componentType != null) {\n          folded = GLSLX.Folder._castValue(componentType, folded);\n\n          if (folded == null) {\n            return null;\n          }\n        }\n\n        $arguments.push(folded);\n      }\n\n      if (folded.resolvedType.isMatrix()) {\n        matrixStride = folded.resolvedType.indexCount();\n      }\n\n      count = count + 1 | 0;\n    }\n\n    // If a matrix argument is given to a matrix constructor, it is an error\n    // to have any other arguments\n    if (type.isMatrix() && matrixStride != 0 && count != 1) {\n      return null;\n    }\n\n    // Native component-based types\n    if (type.componentType() != null) {\n      return GLSLX.Folder._foldComponentConstructor($arguments, type, type.isMatrix() ? matrixStride : 0);\n    }\n\n    // User-defined struct types\n    if (type.symbol != null && type.symbol.isStruct()) {\n      return GLSLX.Folder._foldStruct($arguments, type);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._floatValues = function(node) {\n    var values = [];\n\n    for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\n      values.push(child.asFloat());\n    }\n\n    return values;\n  };\n\n  GLSLX.Folder._foldMultiply = function(node) {\n    var ref;\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n    var leftType = left != null ? left.resolvedType : null;\n    var rightType = right != null ? right.resolvedType : null;\n\n    if (left != null && right != null) {\n      // Vector-matrix multiply\n      if (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) {\n        var stride = leftType.indexCount();\n        var result = GLSLX.Node.createConstructorCall(leftType);\n        var leftValues = GLSLX.Folder._floatValues(left);\n        var rightValues = GLSLX.Folder._floatValues(right);\n\n        for (var i = 0, count1 = stride; i < count1; i = i + 1 | 0) {\n          var total = 0;\n\n          for (var col = 0, count = stride; col < count; col = col + 1 | 0) {\n            total += in_List.get(leftValues, col) * in_List.get(rightValues, col + __imul(i, stride) | 0);\n          }\n\n          result.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total).withType(GLSLX.Type.FLOAT));\n        }\n\n        return result;\n      }\n\n      // Matrix-vector multiply\n      if (leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) {\n        var stride1 = leftType.indexCount();\n        var result1 = GLSLX.Node.createConstructorCall(rightType);\n        var leftValues1 = GLSLX.Folder._floatValues(left);\n        var rightValues1 = GLSLX.Folder._floatValues(right);\n\n        for (var i1 = 0, count3 = stride1; i1 < count3; i1 = i1 + 1 | 0) {\n          var total1 = 0;\n\n          for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\n            total1 += in_List.get(leftValues1, i1 + __imul(row, stride1) | 0) * in_List.get(rightValues1, row);\n          }\n\n          result1.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total1).withType(GLSLX.Type.FLOAT));\n        }\n\n        return result1;\n      }\n\n      // Matrix-matrix multiply\n      if (leftType.isMatrix() && rightType == leftType) {\n        var stride2 = leftType.indexCount();\n        var result2 = GLSLX.Node.createConstructorCall(leftType);\n        var leftValues2 = GLSLX.Folder._floatValues(left);\n        var rightValues2 = GLSLX.Folder._floatValues(right);\n\n        for (var row1 = 0, count6 = stride2; row1 < count6; row1 = row1 + 1 | 0) {\n          for (var col1 = 0, count5 = stride2; col1 < count5; col1 = col1 + 1 | 0) {\n            var total2 = 0;\n\n            for (var i2 = 0, count4 = stride2; i2 < count4; i2 = i2 + 1 | 0) {\n              total2 += in_List.get(leftValues2, col1 + __imul(i2, stride2) | 0) * in_List.get(rightValues2, i2 + __imul(row1, stride2) | 0);\n            }\n\n            result2.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total2).withType(GLSLX.Type.FLOAT));\n          }\n        }\n\n        return result2;\n      }\n\n      return (ref = GLSLX.Folder._foldFloat2(left, right, function(a, b) {\n        return a * b;\n      })) != null ? ref : GLSLX.Folder._foldInt2(left, right, function(a, b) {\n        return __imul(a, b);\n      });\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._castValue = function(type, node) {\n    var value = 0;\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.BOOL: {\n        value = +node.asBool();\n        break;\n      }\n\n      case GLSLX.NodeKind.INT: {\n        value = node.asInt();\n        break;\n      }\n\n      case GLSLX.NodeKind.FLOAT: {\n        value = node.asFloat();\n        break;\n      }\n\n      default: {\n        return null;\n      }\n    }\n\n    switch (type) {\n      case GLSLX.Type.BOOL: {\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(!!value).withType(GLSLX.Type.BOOL);\n      }\n\n      case GLSLX.Type.INT: {\n        return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(value | 0).withType(GLSLX.Type.INT);\n      }\n\n      case GLSLX.Type.FLOAT: {\n        return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(value).withType(GLSLX.Type.FLOAT);\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldComponentConstructor = function($arguments, type, matrixStride) {\n    var componentCount = type.componentCount();\n    var componentType = type.componentType();\n    var node = GLSLX.Node.createConstructorCall(type);\n    assert(componentCount > 0);\n\n    // Passing a single component as an argument always works\n    if ($arguments.length == 1) {\n      var argument = in_List.first($arguments);\n\n      if (argument.resolvedType != componentType) {\n        return null;\n      }\n\n      // When doing this with a matrix, only the diagonal is filled\n      var isMatrix = type.isMatrix();\n      var stride = type.indexCount();\n\n      // Fill the target by repeating the single component\n      for (var i = 0, count = componentCount; i < count; i = i + 1 | 0) {\n        var isOffMatrixDiagonal = isMatrix && (i % (stride + 1 | 0) | 0) != 0;\n        node.appendChild(isOffMatrixDiagonal ? new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(0).withType(GLSLX.Type.FLOAT) : argument.clone());\n      }\n    }\n\n    // If a matrix is constructed from a matrix, then each component (column i,\n    // row j) in the result that has a corresponding component (column i, row j)\n    // in the argument will be initialized from there. All other components will\n    // be initialized to the identity matrix.\n    else if (matrixStride != 0) {\n      var stride1 = type.indexCount();\n      assert(type.isMatrix());\n      assert(__imul(stride1, stride1) == componentCount);\n\n      for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\n        for (var col = 0, count1 = stride1; col < count1; col = col + 1 | 0) {\n          node.appendChild(col < matrixStride && row < matrixStride ? in_List.get($arguments, col + __imul(row, matrixStride) | 0) : new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(col == row ? 1 : 0).withType(GLSLX.Type.FLOAT));\n        }\n      }\n    }\n\n    // Multiple arguments are more involved\n    else {\n      // Extra arguments are ignored\n      if ($arguments.length < componentCount) {\n        return null;\n      }\n\n      // The constructed value is represented as a constructor call\n      for (var i1 = 0, count3 = componentCount; i1 < count3; i1 = i1 + 1 | 0) {\n        var argument1 = in_List.get($arguments, i1);\n\n        // All casts should be resolved by this point\n        if (argument1.resolvedType != componentType) {\n          return null;\n        }\n\n        node.appendChild(argument1);\n      }\n    }\n\n    // Don't wrap primitive types\n    if (type.indexType() == null) {\n      return node.lastChild().remove();\n    }\n\n    return node;\n  };\n\n  GLSLX.Folder._foldStruct = function($arguments, type) {\n    var variables = type.symbol.asStruct().variables;\n    var node = GLSLX.Node.createConstructorCall(type);\n\n    // Structs can only be constructed with the exact number of arguments\n    if ($arguments.length != variables.length) {\n      return null;\n    }\n\n    // The constructed value is represented as a constructor call\n    for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n      if (in_List.get($arguments, i).resolvedType != in_List.get(variables, i).type.resolvedType) {\n        return null;\n      }\n\n      node.appendChild(in_List.get($arguments, i));\n    }\n\n    return node;\n  };\n\n  GLSLX.Folder._foldBinaryEquality = function(node) {\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    if (left != null && right != null) {\n      var value = left.looksTheSameAs(right);\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(node.kind == GLSLX.NodeKind.EQUAL ? value : !value).withType(GLSLX.Type.BOOL);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldComponentwiseUnary = function(node, componentType, argumentKind, op) {\n    if (node.kind == GLSLX.NodeKind.CALL && node.callTarget().kind == GLSLX.NodeKind.TYPE && node.callTarget().resolvedType.componentType() == componentType) {\n      var result = GLSLX.Node.createConstructorCall(node.callTarget().resolvedType);\n\n      for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\n        var folded = GLSLX.Folder.fold(child);\n\n        if (folded == null || folded.kind != argumentKind) {\n          return null;\n        }\n\n        result.appendChild(op(folded));\n      }\n\n      return result;\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldFloat1 = function(node, op) {\n    if (node.kind == GLSLX.NodeKind.FLOAT) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(node.asFloat())).withType(GLSLX.Type.FLOAT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(x) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(x.asFloat())).withType(GLSLX.Type.FLOAT);\n    });\n  };\n\n  GLSLX.Folder._foldInt1 = function(node, op) {\n    if (node.kind == GLSLX.NodeKind.INT) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(node.asInt())).withType(GLSLX.Type.INT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(x) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(x.asInt())).withType(GLSLX.Type.INT);\n    });\n  };\n\n  GLSLX.Folder._foldComponentwiseBinary = function(left, right, componentType, argumentKind, op) {\n    var leftHasComponents = left.kind == GLSLX.NodeKind.CALL && left.callTarget().kind == GLSLX.NodeKind.TYPE && left.callTarget().resolvedType.componentType() == componentType;\n    var rightHasComponents = right.kind == GLSLX.NodeKind.CALL && right.callTarget().kind == GLSLX.NodeKind.TYPE && right.callTarget().resolvedType.componentType() == componentType;\n\n    // Vector-vector binary operator\n    if (leftHasComponents && rightHasComponents && right.resolvedType == left.resolvedType) {\n      var result = GLSLX.Node.createConstructorCall(left.resolvedType);\n      var leftChild = left.callTarget().nextSibling();\n      var rightChild = right.callTarget().nextSibling();\n\n      while (leftChild != null && rightChild != null) {\n        var foldedLeft = GLSLX.Folder.fold(leftChild);\n        var foldedRight = GLSLX.Folder.fold(rightChild);\n\n        if (foldedLeft == null || foldedLeft.kind != argumentKind || foldedRight == null || foldedRight.kind != argumentKind) {\n          return null;\n        }\n\n        result.appendChild(op(foldedLeft, foldedRight));\n        leftChild = leftChild.nextSibling();\n        rightChild = rightChild.nextSibling();\n      }\n\n      if (leftChild == null && rightChild == null) {\n        return result;\n      }\n    }\n\n    // Vector-scalar binary operator\n    else if (leftHasComponents && right.kind == argumentKind) {\n      var result1 = GLSLX.Node.createConstructorCall(left.resolvedType);\n\n      for (var child = left.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\n        var folded = GLSLX.Folder.fold(child);\n\n        if (folded == null || folded.kind != argumentKind) {\n          return null;\n        }\n\n        result1.appendChild(op(folded, right));\n      }\n\n      return result1;\n    }\n\n    // Scalar-vector binary operator\n    else if (left.kind == argumentKind && rightHasComponents) {\n      var result2 = GLSLX.Node.createConstructorCall(right.resolvedType);\n\n      for (var child1 = right.callTarget().nextSibling(); child1 != null; child1 = child1.nextSibling()) {\n        var folded1 = GLSLX.Folder.fold(child1);\n\n        if (folded1 == null || folded1.kind != argumentKind) {\n          return null;\n        }\n\n        result2.appendChild(op(left, folded1));\n      }\n\n      return result2;\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldFloat2 = function(left, right, op) {\n    if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.FLOAT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(a, b) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(a.asFloat(), b.asFloat())).withType(GLSLX.Type.FLOAT);\n    });\n  };\n\n  GLSLX.Folder._foldInt2 = function(left, right, op) {\n    if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(left.asInt(), right.asInt())).withType(GLSLX.Type.INT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(a, b) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(a.asInt(), b.asInt())).withType(GLSLX.Type.INT);\n    });\n  };\n\n  GLSLX.Folder._foldUnaryBool = function(node, op) {\n    var value = GLSLX.Folder.fold(node.unaryValue());\n\n    if (value != null && value.kind == GLSLX.NodeKind.BOOL) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(value.asBool())).withType(GLSLX.Type.BOOL);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldUnaryFloatOrInt = function(node, floatOp, intOp) {\n    var ref;\n    var value = GLSLX.Folder.fold(node.unaryValue());\n\n    if (value != null) {\n      return (ref = GLSLX.Folder._foldFloat1(value, floatOp)) != null ? ref : GLSLX.Folder._foldInt1(value, intOp);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldBinaryBool = function(node, op) {\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    if (left != null && right != null && left.kind == GLSLX.NodeKind.BOOL && right.kind == GLSLX.NodeKind.BOOL) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asBool(), right.asBool())).withType(GLSLX.Type.BOOL);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldBinaryFloatOrInt = function(node, floatOp, intOp) {\n    var ref;\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    if (left != null && right != null) {\n      return (ref = GLSLX.Folder._foldFloat2(left, right, floatOp)) != null ? ref : GLSLX.Folder._foldInt2(left, right, intOp);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldBinaryFloatOrIntToBool = function(node, op) {\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    // The comparison operators only work on scalars in GLSL. To do comparisons\n    // on vectors, the functions greaterThan(), lessThan(), greaterThanEqual(),\n    // and lessThanEqual() must be used.\n    if (left != null && right != null) {\n      if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.BOOL);\n      }\n\n      if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asInt(), right.asInt())).withType(GLSLX.Type.BOOL);\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.DiagnosticKind = {\n    ERROR: 0,\n    WARNING: 1\n  };\n\n  GLSLX.Diagnostic = function(kind, range, text) {\n    this.kind = kind;\n    this.range = range;\n    this.text = text;\n    this.noteRange = null;\n    this.noteText = '';\n  };\n\n  GLSLX.Log = function() {\n    this.diagnostics = [];\n    this.warningCount = 0;\n    this.errorCount = 0;\n  };\n\n  GLSLX.Log.prototype.hasErrors = function() {\n    return this.errorCount != 0;\n  };\n\n  GLSLX.Log.prototype.error = function(range, text) {\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.ERROR, range, text));\n    this.errorCount = this.errorCount + 1 | 0;\n  };\n\n  GLSLX.Log.prototype.warning = function(range, text) {\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.WARNING, range, text));\n    this.warningCount = this.warningCount + 1 | 0;\n  };\n\n  GLSLX.Log.prototype.note = function(range, text) {\n    var last = in_List.last(this.diagnostics);\n    last.noteRange = range;\n    last.noteText = text;\n  };\n\n  GLSLX.Log.prototype.syntaxWarningUnknownExtension = function(range, name) {\n    this.warning(range, 'The extension \"' + name + '\" is not in the known list of valid WebGL extensions');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInvalidString = function(range) {\n    this.error(range, 'Invalid string literal');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorDisabledExtension = function(range, name, extension) {\n    this.error(range, 'Cannot use \"' + name + '\" from disabled extension \"' + extension + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorExtraData = function(range, text) {\n    this.error(range, 'Syntax error \"' + text + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorReservedWord = function(range) {\n    this.error(range, '\"' + range.toString() + '\" is a reserved word');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorUnexpectedToken = function(token) {\n    this.error(token.range, 'Unexpected ' + in_List.get(GLSLX.in_TokenKind._strings, token.kind));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorExpectedToken1 = function(range, expected) {\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorExpectedToken2 = function(range, found, expected) {\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected) + ' but found ' + in_List.get(GLSLX.in_TokenKind._strings, found));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorBadSymbolReference = function(range) {\n    this.error(range, 'There is no symbol called \"' + range.toString() + '\" in the current scope');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorDuplicateSymbolDefinition = function(range, previous) {\n    this.error(range, 'There is already a symbol called \"' + range.toString() + '\" in the current scope');\n    this.note(previous, 'The previous definition of \"' + previous.toString() + '\" is here');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorOutsideLoop = function(range) {\n    this.error(range, 'This statement cannot be used outside a loop');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorStructVariableInitializer = function(range) {\n    this.error(range, 'Cannot initialize struct variables');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInsideStruct = function(range) {\n    this.error(range, 'This statement cannot be used inside a struct');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInsideFunction = function(range) {\n    this.error(range, 'This statement cannot be used inside a function');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorOutsideFunction = function(range) {\n    this.error(range, 'This statement cannot be used outside a function');\n  };\n\n  GLSLX.Log.prototype.semanticErrorIncludeWithoutFileAccess = function(range) {\n    this.error(range, 'Cannot include files without access to a file system');\n  };\n\n  GLSLX.Log.prototype.semanticErrorIncludeBadPath = function(range, path) {\n    this.error(range, 'Cannot read the file ' + JSON.stringify(path));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorDifferentReturnType = function(range, name, type, expected, previous) {\n    this.error(range, 'Cannot change the return type of \"' + name + '\" to type \"' + type.toString() + '\"');\n    this.note(previous, 'The forward declaration of \"' + name + '\" has a return type of \"' + expected.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorBadQualifier = function(range) {\n    this.error(range, 'Cannot use this qualifier here');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorConstantRequired = function(range) {\n    this.error(range, 'This value must be a compile-time constant');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInvalidArraySize = function(range, count) {\n    this.error(range, 'Cannot declare an array with a size of \"' + count.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorMissingArraySize = function(range) {\n    this.error(range, 'All array sizes must be specified');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorMultidimensionalArray = function(range) {\n    this.error(range, 'Multidimensional arrays are not a part of the language');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInvalidOperator = function(range) {\n    this.error(range, 'The operator \"' + range.toString() + '\" is reserved and cannot be used');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadConversion = function(range, from, to) {\n    this.error(range, 'Cannot convert from type \"' + from.toString() + '\" to type \"' + to.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorUnexpectedType = function(range, type) {\n    this.error(range, 'Unexpected type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadVariableType = function(range, type) {\n    this.error(range, 'Cannot create a variable of type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadMember = function(range, type, name) {\n    this.error(range, 'Cannot find \"' + name + '\" on type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadSwizzle = function(range, type, name) {\n    this.error(range, 'Invalid swizzle \"' + name + '\" on type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadSwizzleAssignment = function(range, field) {\n    this.error(range, 'The field \"' + field + '\" cannot be specified multiple times when used as a storage location');\n  };\n\n  GLSLX.Log.prototype.semanticErrorMustCallFunction = function(range, name) {\n    this.error(range, 'The function \"' + name + '\" must be called');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadCall = function(range, type) {\n    this.error(range, 'Cannot call type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadConstructorValue = function(range, type, $constructor) {\n    this.error(range, 'Cannot use value of type \"' + type.toString() + '\" when constructing type \"' + $constructor.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorExtraConstructorValue = function(range, type, count, total) {\n    this.error(range, 'The constructor for type \"' + type.toString() + '\" only takes ' + count.toString() + ' argument' + (count != 1 ? 's' : '') + ' and this argument would bring the total to ' + total.toString());\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadConstructorCount = function(range, type, count) {\n    this.error(range, 'Cannot construct type \"' + type.toString() + '\" with ' + count.toString() + ' argument' + (count != 1 ? 's' : ''));\n  };\n\n  GLSLX.Log.prototype.semanticErrorArgumentCountFunction = function(range, expected, found, name, $function) {\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when calling function \"' + name + '\"');\n\n    if ($function != null) {\n      this.note($function, 'The definition of function \"' + name + '\" is here');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorArgumentCountConstructor = function(range, expected, found, name, struct) {\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when constructing type \"' + name + '\"');\n\n    if (struct != null) {\n      this.note(struct, 'The definition of struct \"' + name + '\" is here');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadOverloadMatch = function(range, name) {\n    this.error(range, 'No matching overload for function \"' + name + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadHookTypes = function(range, left, right) {\n    this.error(range, 'Cannot merge type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorArrayHook = function(range, type) {\n    if (type.isArrayOf != null) {\n      this.error(range, 'Cannot use a conditional expression with array type \"' + type.toString() + '\"');\n    }\n\n    else {\n      this.error(range, 'Cannot use a conditional expression with type \"' + type.toString() + '\" because it contains an array');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorArrayAssignment = function(range, type) {\n    if (type.isArrayOf != null) {\n      this.error(range, 'Cannot assign to array type \"' + type.toString() + '\"');\n    }\n\n    else {\n      this.error(range, 'Cannot assign to type \"' + type.toString() + '\" because it contains an array');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadUnaryOperator = function(range, operator, type) {\n    this.error(range, 'No unary operator \"' + operator + '\" for type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadBinaryOperator = function(range, operator, left, right) {\n    if (left == right) {\n      this.error(range, 'There is no operator \"' + operator + '\" defined for type \"' + left.toString() + '\"');\n    }\n\n    else {\n      this.error(range, 'No binary operator \"' + operator + '\" for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadIndex = function(range, left, right) {\n    this.error(range, 'No index operator for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorOutOfBoundsIndex = function(range, value, type) {\n    this.error(range, 'Index \"' + value.toString() + '\" is out of bounds for type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadStorage = function(range) {\n    this.error(range, 'Cannot store to this location');\n  };\n\n  GLSLX.Log.prototype.semanticErrorUninitializedConstant = function(range) {\n    this.error(range, 'Constants must be initialized');\n  };\n\n  GLSLX.Log.prototype.semanticErrorMissingReturn = function(range, name, type) {\n    this.error(range, 'All control paths for \"' + name + '\" must return a value of type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadMatrixConstructor = function(range) {\n    this.error(range, 'If a matrix argument is given to a matrix constructor, it is an error to have any other arguments');\n  };\n\n  GLSLX.NodeKind = {\n    // Other\n    GLOBAL: 0,\n    STRUCT_BLOCK: 1,\n    VARIABLE: 2,\n\n    // Statements\n    BLOCK: 3,\n    BREAK: 4,\n    CONTINUE: 5,\n    DISCARD: 6,\n    DO_WHILE: 7,\n    EXPRESSION: 8,\n    EXTENSION: 9,\n    FOR: 10,\n    FUNCTION: 11,\n    IF: 12,\n    MODIFIER_BLOCK: 13,\n    PRECISION: 14,\n    RETURN: 15,\n    STRUCT: 16,\n    VARIABLES: 17,\n    VERSION: 18,\n    WHILE: 19,\n\n    // Expressions\n    CALL: 20,\n    DOT: 21,\n    HOOK: 22,\n    NAME: 23,\n    PARSE_ERROR: 24,\n    SEQUENCE: 25,\n    TYPE: 26,\n    UNKNOWN_CONSTANT: 27,\n\n    // Literals\n    BOOL: 28,\n    FLOAT: 29,\n    INT: 30,\n\n    // Unary prefix\n    NEGATIVE: 31,\n    NOT: 32,\n    POSITIVE: 33,\n\n    // Unary prefix assign\n    PREFIX_DECREMENT: 34,\n    PREFIX_INCREMENT: 35,\n\n    // Unary postfix assign\n    POSTFIX_DECREMENT: 36,\n    POSTFIX_INCREMENT: 37,\n\n    // Binary\n    ADD: 38,\n    DIVIDE: 39,\n    EQUAL: 40,\n    GREATER_THAN: 41,\n    GREATER_THAN_OR_EQUAL: 42,\n    INDEX: 43,\n    LESS_THAN: 44,\n    LESS_THAN_OR_EQUAL: 45,\n    LOGICAL_AND: 46,\n    LOGICAL_OR: 47,\n    LOGICAL_XOR: 48,\n    MULTIPLY: 49,\n    NOT_EQUAL: 50,\n    SUBTRACT: 51,\n\n    // Binary assignment\n    ASSIGN: 52,\n    ASSIGN_ADD: 53,\n    ASSIGN_DIVIDE: 54,\n    ASSIGN_MULTIPLY: 55,\n    ASSIGN_SUBTRACT: 56\n  };\n\n  GLSLX.Node = function(kind) {\n    this.id = GLSLX.Node._createID();\n    this.kind = kind;\n    this.range = null;\n    this.internalRange = null;\n    this.symbol = null;\n    this.resolvedType = null;\n    this._literal = 0;\n    this._text = null;\n    this._parent = null;\n    this._firstChild = null;\n    this._lastChild = null;\n    this._previousSibling = null;\n    this._nextSibling = null;\n    this.hasControlFlowAtEnd = false;\n  };\n\n  GLSLX.Node.prototype._copyMembersFrom = function(node) {\n    this.kind = node.kind;\n    this.range = node.range;\n    this.internalRange = node.internalRange;\n    this.symbol = node.symbol;\n    this.resolvedType = node.resolvedType;\n    this._literal = node._literal;\n    this._text = node._text;\n  };\n\n  GLSLX.Node.prototype.cloneWithoutChildren = function() {\n    var clone = new GLSLX.Node(this.kind);\n    clone._copyMembersFrom(this);\n    return clone;\n  };\n\n  GLSLX.Node.prototype.clone = function() {\n    var clone = this.cloneWithoutChildren();\n\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\n      clone.appendChild(child.clone());\n    }\n\n    return clone;\n  };\n\n  GLSLX.Node.prototype.parent = function() {\n    return this._parent;\n  };\n\n  GLSLX.Node.prototype.firstChild = function() {\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.lastChild = function() {\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.nextSibling = function() {\n    return this._nextSibling;\n  };\n\n  // This is cheaper than childCount == 0\n  GLSLX.Node.prototype.hasChildren = function() {\n    return this._firstChild != null;\n  };\n\n  GLSLX.Node.prototype.childCount = function() {\n    var count = 0;\n\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\n      count = count + 1 | 0;\n    }\n\n    return count;\n  };\n\n  GLSLX.Node.prototype.childAt = function(index) {\n    assert(0 <= index && index < this.childCount());\n    var child = this._firstChild;\n\n    while (index != 0) {\n      child = child._nextSibling;\n      index = index - 1 | 0;\n    }\n\n    return child;\n  };\n\n  GLSLX.Node.prototype.withType = function(value) {\n    this.resolvedType = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withSymbol = function(value) {\n    this.symbol = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withBool = function(value) {\n    this._literal = +value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withInt = function(value) {\n    this._literal = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withFloat = function(value) {\n    this._literal = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withText = function(value) {\n    this._text = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withRange = function(value) {\n    this.range = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withInternalRange = function(value) {\n    this.internalRange = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.appendChild = function(node) {\n    if (node == null) {\n      return this;\n    }\n\n    assert(node != this);\n    assert(node._parent == null);\n    assert(node._previousSibling == null);\n    assert(node._nextSibling == null);\n    node._parent = this;\n\n    if (this.hasChildren()) {\n      node._previousSibling = this._lastChild;\n      this._lastChild._nextSibling = node;\n      this._lastChild = node;\n    }\n\n    else {\n      this._lastChild = this._firstChild = node;\n    }\n\n    return this;\n  };\n\n  GLSLX.Node.prototype.remove = function() {\n    assert(this._parent != null);\n\n    if (this._previousSibling != null) {\n      assert(this._previousSibling._nextSibling == this);\n      this._previousSibling._nextSibling = this._nextSibling;\n    }\n\n    else {\n      assert(this._parent._firstChild == this);\n      this._parent._firstChild = this._nextSibling;\n    }\n\n    if (this._nextSibling != null) {\n      assert(this._nextSibling._previousSibling == this);\n      this._nextSibling._previousSibling = this._previousSibling;\n    }\n\n    else {\n      assert(this._parent._lastChild == this);\n      this._parent._lastChild = this._previousSibling;\n    }\n\n    this._parent = null;\n    this._previousSibling = null;\n    this._nextSibling = null;\n    return this;\n  };\n\n  GLSLX.Node.prototype.insertChildBefore = function(after, before) {\n    if (before == null) {\n      return this;\n    }\n\n    assert(before != after);\n    assert(before._parent == null);\n    assert(before._previousSibling == null);\n    assert(before._nextSibling == null);\n    assert(after == null || after._parent == this);\n\n    if (after == null) {\n      return this.appendChild(before);\n    }\n\n    before._parent = this;\n    before._previousSibling = after._previousSibling;\n    before._nextSibling = after;\n\n    if (after._previousSibling != null) {\n      assert(after == after._previousSibling._nextSibling);\n      after._previousSibling._nextSibling = before;\n    }\n\n    else {\n      assert(after == this._firstChild);\n      this._firstChild = before;\n    }\n\n    after._previousSibling = before;\n    return this;\n  };\n\n  GLSLX.Node.prototype.isTrue = function() {\n    return this.kind == GLSLX.NodeKind.BOOL && this.asBool();\n  };\n\n  GLSLX.Node.prototype.isFalse = function() {\n    return this.kind == GLSLX.NodeKind.BOOL && !this.asBool();\n  };\n\n  GLSLX.Node.prototype.isCallTarget = function() {\n    return this.parent() != null && this.parent().kind == GLSLX.NodeKind.CALL && this.parent().callTarget() == this;\n  };\n\n  GLSLX.Node.prototype.isAssignTarget = function() {\n    return this.parent() != null && (GLSLX.in_NodeKind.isUnaryAssign(this.parent().kind) || GLSLX.in_NodeKind.isBinaryAssign(this.parent().kind) && this.parent().binaryLeft() == this);\n  };\n\n  GLSLX.Node.prototype.isEmptySequence = function() {\n    return this.kind == GLSLX.NodeKind.SEQUENCE && !this.hasChildren();\n  };\n\n  GLSLX.Node.prototype.looksTheSameAs = function(node) {\n    if (this.kind == node.kind) {\n      switch (this.kind) {\n        case GLSLX.NodeKind.BOOL: {\n          return this.asBool() == node.asBool();\n        }\n\n        case GLSLX.NodeKind.FLOAT: {\n          return this.asFloat() == node.asFloat();\n        }\n\n        case GLSLX.NodeKind.INT: {\n          return this.asInt() == node.asInt();\n        }\n\n        case GLSLX.NodeKind.NAME: {\n          return this.symbol == node.symbol;\n        }\n\n        case GLSLX.NodeKind.TYPE: {\n          return this.resolvedType == node.resolvedType;\n        }\n\n        case GLSLX.NodeKind.DOT: {\n          return this.dotTarget().looksTheSameAs(node.dotTarget()) && this.symbol == node.symbol && this.asString() == node.asString();\n        }\n\n        case GLSLX.NodeKind.HOOK: {\n          return this.hookTest().looksTheSameAs(node.hookTest()) && this.hookTrue().looksTheSameAs(node.hookTrue()) && this.hookFalse().looksTheSameAs(node.hookFalse());\n        }\n\n        case GLSLX.NodeKind.CALL: {\n          var left = this.firstChild();\n          var right = node.firstChild();\n\n          while (left != null && right != null) {\n            if (!left.looksTheSameAs(right)) {\n              return false;\n            }\n\n            left = left.nextSibling();\n            right = right.nextSibling();\n          }\n\n          return left == null && right == null;\n        }\n\n        default: {\n          if (GLSLX.in_NodeKind.isUnary(this.kind)) {\n            return this.unaryValue().looksTheSameAs(node.unaryValue());\n          }\n\n          if (GLSLX.in_NodeKind.isBinary(this.kind)) {\n            return this.binaryLeft().looksTheSameAs(node.binaryLeft()) && this.binaryRight().looksTheSameAs(node.binaryRight());\n          }\n          break;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  GLSLX.Node.createDoWhile = function(body, test) {\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.DO_WHILE).appendChild(body).appendChild(test);\n  };\n\n  GLSLX.Node.createExpression = function(value) {\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.EXPRESSION).appendChild(value);\n  };\n\n  GLSLX.Node.createFor = function(setup, test, update, body) {\n    assert(setup == null || GLSLX.in_NodeKind.isExpression(setup.kind) || setup.kind == GLSLX.NodeKind.VARIABLES);\n    assert(test == null || GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(update == null || GLSLX.in_NodeKind.isExpression(update.kind));\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.FOR).appendChild(setup == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : setup).appendChild(test == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : test).appendChild(update == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : update).appendChild(body);\n  };\n\n  GLSLX.Node.createIf = function(test, yes, no) {\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(GLSLX.in_NodeKind.isStatement(yes.kind));\n    assert(no == null || GLSLX.in_NodeKind.isStatement(no.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.IF).appendChild(test).appendChild(yes).appendChild(no);\n  };\n\n  GLSLX.Node.createPrecision = function(flags, type) {\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.PRECISION).withInt(flags).appendChild(type);\n  };\n\n  GLSLX.Node.createReturn = function(value) {\n    assert(value == null || GLSLX.in_NodeKind.isExpression(value.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.RETURN).appendChild(value);\n  };\n\n  GLSLX.Node.createStruct = function(symbol, block, variables) {\n    assert(block.kind == GLSLX.NodeKind.STRUCT_BLOCK);\n    assert(variables == null || variables.kind == GLSLX.NodeKind.VARIABLES);\n    return new GLSLX.Node(GLSLX.NodeKind.STRUCT).withSymbol(symbol).appendChild(block).appendChild(variables);\n  };\n\n  GLSLX.Node.createVariables = function(flags, type) {\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.VARIABLES).withInt(flags).appendChild(type);\n  };\n\n  GLSLX.Node.createWhile = function(test, body) {\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.WHILE).appendChild(test).appendChild(body);\n  };\n\n  GLSLX.Node.createCall = function(value) {\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.CALL).appendChild(value);\n  };\n\n  GLSLX.Node.createConstructorCall = function(type) {\n    return GLSLX.Node.createCall(new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type)).withType(type);\n  };\n\n  GLSLX.Node.createDot = function(value, text) {\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\n    assert(text != null);\n    return new GLSLX.Node(GLSLX.NodeKind.DOT).appendChild(value).withText(text);\n  };\n\n  GLSLX.Node.createHook = function(test, yes, no) {\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(GLSLX.in_NodeKind.isExpression(yes.kind));\n    assert(GLSLX.in_NodeKind.isExpression(no.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.HOOK).appendChild(test).appendChild(yes).appendChild(no);\n  };\n\n  GLSLX.Node.createUnary = function(kind, value) {\n    assert(GLSLX.in_NodeKind.isUnary(kind));\n    return new GLSLX.Node(kind).appendChild(value);\n  };\n\n  GLSLX.Node.createBinary = function(kind, left, right) {\n    assert(GLSLX.in_NodeKind.isBinary(kind));\n    return new GLSLX.Node(kind).appendChild(left).appendChild(right);\n  };\n\n  GLSLX.Node.prototype.doWhileBody = function() {\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.doWhileTest = function() {\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.expressionValue = function() {\n    assert(this.kind == GLSLX.NodeKind.EXPRESSION);\n    assert(this.childCount() == 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.forSetup = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind) || this._firstChild.kind == GLSLX.NodeKind.VARIABLES);\n    return this._firstChild.isEmptySequence() ? null : this._firstChild;\n  };\n\n  GLSLX.Node.prototype.forTest = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind) || this._firstChild._nextSibling.kind == GLSLX.NodeKind.VARIABLES);\n    return this._firstChild._nextSibling.isEmptySequence() ? null : this._firstChild._nextSibling;\n  };\n\n  GLSLX.Node.prototype.forUpdate = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild._previousSibling.kind));\n    return this._lastChild._previousSibling.isEmptySequence() ? null : this._lastChild._previousSibling;\n  };\n\n  GLSLX.Node.prototype.forBody = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.ifTest = function() {\n    assert(this.kind == GLSLX.NodeKind.IF);\n    assert(this.childCount() == 2 || this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.ifTrue = function() {\n    assert(this.kind == GLSLX.NodeKind.IF);\n    assert(this.childCount() == 2 || this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling.kind));\n    return this._firstChild._nextSibling;\n  };\n\n  GLSLX.Node.prototype.ifFalse = function() {\n    assert(this.kind == GLSLX.NodeKind.IF);\n    assert(this.childCount() == 2 || this.childCount() == 3);\n    assert(this._firstChild._nextSibling._nextSibling == null || GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling._nextSibling.kind));\n    return this._firstChild._nextSibling._nextSibling;\n  };\n\n  GLSLX.Node.prototype.returnValue = function() {\n    assert(this.kind == GLSLX.NodeKind.RETURN);\n    assert(this.childCount() <= 1);\n    assert(this._firstChild == null || GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.variablesType = function() {\n    assert(this.kind == GLSLX.NodeKind.VARIABLES);\n    assert(this.childCount() >= 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.whileTest = function() {\n    assert(this.kind == GLSLX.NodeKind.WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.whileBody = function() {\n    assert(this.kind == GLSLX.NodeKind.WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.callTarget = function() {\n    assert(this.kind == GLSLX.NodeKind.CALL);\n    assert(this.childCount() >= 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.dotTarget = function() {\n    assert(this.kind == GLSLX.NodeKind.DOT);\n    assert(this.childCount() == 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.hookTest = function() {\n    assert(this.kind == GLSLX.NodeKind.HOOK);\n    assert(this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.hookTrue = function() {\n    assert(this.kind == GLSLX.NodeKind.HOOK);\n    assert(this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind));\n    return this._firstChild._nextSibling;\n  };\n\n  GLSLX.Node.prototype.hookFalse = function() {\n    assert(this.kind == GLSLX.NodeKind.HOOK);\n    assert(this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.asString = function() {\n    assert(this.kind == GLSLX.NodeKind.DOT);\n    assert(this._text != null);\n    return this._text;\n  };\n\n  GLSLX.Node.prototype.asBool = function() {\n    assert(this.kind == GLSLX.NodeKind.BOOL);\n    return !!this._literal;\n  };\n\n  GLSLX.Node.prototype.asFloat = function() {\n    assert(this.kind == GLSLX.NodeKind.FLOAT);\n    return this._literal;\n  };\n\n  GLSLX.Node.prototype.asInt = function() {\n    assert(this.kind == GLSLX.NodeKind.INT);\n    return this._literal | 0;\n  };\n\n  GLSLX.Node.prototype.unaryValue = function() {\n    assert(GLSLX.in_NodeKind.isUnary(this.kind));\n    assert(this.childCount() == 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.binaryLeft = function() {\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.binaryRight = function() {\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node._createID = function() {\n    GLSLX.Node._nextID = GLSLX.Node._nextID + 1 | 0;\n    return GLSLX.Node._nextID;\n  };\n\n  GLSLX.Parser = {};\n\n  GLSLX.Parser.typeParselet = function(type) {\n    return function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.unaryPrefix = function(kind) {\n    assert(GLSLX.in_NodeKind.isUnaryPrefix(kind));\n    return function(context, token, value) {\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(token.range, value.range)).withInternalRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.unaryPostfix = function(kind) {\n    assert(GLSLX.in_NodeKind.isUnaryPostfix(kind));\n    return function(context, value, token) {\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(value.range, token.range)).withInternalRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.binaryParselet = function(kind) {\n    assert(GLSLX.in_NodeKind.isBinary(kind));\n    return function(context, left, token, right) {\n      return GLSLX.Node.createBinary(kind, left, right).withRange(GLSLX.Range.span(left.range, right.range)).withInternalRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.parseInt = function(text) {\n    if (text.length > 1 && in_string.get1(text, 0) == 48 && (in_string.get1(text, 1) != 120 && in_string.get1(text, 1) != 88)) {\n      return parseInt(text, 8);\n    }\n\n    return text | 0;\n  };\n\n  GLSLX.Parser.createExpressionParser = function() {\n    var pratt = new GLSLX.Pratt();\n    var invalidUnaryOperator = function(context, token, value) {\n      context.log.syntaxErrorInvalidOperator(token.range);\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(token.range, value.range));\n    };\n    var invalidBinaryOperator = function(context, left, token, right) {\n      context.log.syntaxErrorInvalidOperator(token.range);\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(left.range, right.range));\n    };\n    pratt.literal(GLSLX.TokenKind.TRUE, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(true).withType(GLSLX.Type.BOOL).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.FALSE, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(false).withType(GLSLX.Type.BOOL).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.INT_LITERAL, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(GLSLX.Parser.parseInt(token.range.toString())).withType(GLSLX.Type.INT).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.FLOAT_LITERAL, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(+token.range.toString()).withType(GLSLX.Type.FLOAT).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.BOOL, GLSLX.Parser.typeParselet(GLSLX.Type.BOOL));\n    pratt.literal(GLSLX.TokenKind.BVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC2));\n    pratt.literal(GLSLX.TokenKind.BVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC3));\n    pratt.literal(GLSLX.TokenKind.BVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC4));\n    pratt.literal(GLSLX.TokenKind.FLOAT, GLSLX.Parser.typeParselet(GLSLX.Type.FLOAT));\n    pratt.literal(GLSLX.TokenKind.INT, GLSLX.Parser.typeParselet(GLSLX.Type.INT));\n    pratt.literal(GLSLX.TokenKind.IVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC2));\n    pratt.literal(GLSLX.TokenKind.IVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC3));\n    pratt.literal(GLSLX.TokenKind.IVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC4));\n    pratt.literal(GLSLX.TokenKind.MAT2, GLSLX.Parser.typeParselet(GLSLX.Type.MAT2));\n    pratt.literal(GLSLX.TokenKind.MAT3, GLSLX.Parser.typeParselet(GLSLX.Type.MAT3));\n    pratt.literal(GLSLX.TokenKind.MAT4, GLSLX.Parser.typeParselet(GLSLX.Type.MAT4));\n    pratt.literal(GLSLX.TokenKind.VEC2, GLSLX.Parser.typeParselet(GLSLX.Type.VEC2));\n    pratt.literal(GLSLX.TokenKind.VEC3, GLSLX.Parser.typeParselet(GLSLX.Type.VEC3));\n    pratt.literal(GLSLX.TokenKind.VEC4, GLSLX.Parser.typeParselet(GLSLX.Type.VEC4));\n    pratt.literal(GLSLX.TokenKind.VOID, GLSLX.Parser.typeParselet(GLSLX.Type.VOID));\n    pratt.prefix(GLSLX.TokenKind.COMPLEMENT, GLSLX.Precedence.UNARY_PREFIX, invalidUnaryOperator);\n    pratt.prefix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_DECREMENT));\n    pratt.prefix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_INCREMENT));\n    pratt.prefix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NEGATIVE));\n    pratt.prefix(GLSLX.TokenKind.NOT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NOT));\n    pratt.prefix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.POSITIVE));\n    pratt.postfix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_DECREMENT));\n    pratt.postfix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_INCREMENT));\n    pratt.infix(GLSLX.TokenKind.DIVIDE, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.DIVIDE));\n    pratt.infix(GLSLX.TokenKind.EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.EQUAL));\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN));\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN_OR_EQUAL));\n    pratt.infix(GLSLX.TokenKind.LESS_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN));\n    pratt.infix(GLSLX.TokenKind.LESS_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN_OR_EQUAL));\n    pratt.infix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.SUBTRACT));\n    pratt.infix(GLSLX.TokenKind.MULTIPLY, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.MULTIPLY));\n    pratt.infix(GLSLX.TokenKind.NOT_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.NOT_EQUAL));\n    pratt.infix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ADD));\n    pratt.infix(GLSLX.TokenKind.REMAINDER, GLSLX.Precedence.MULTIPLY, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.SHIFT_LEFT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.SHIFT_RIGHT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.LOGICAL_OR, GLSLX.Precedence.LOGICAL_OR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_OR));\n    pratt.infix(GLSLX.TokenKind.LOGICAL_XOR, GLSLX.Precedence.LOGICAL_XOR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_XOR));\n    pratt.infix(GLSLX.TokenKind.LOGICAL_AND, GLSLX.Precedence.LOGICAL_AND, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_AND));\n    pratt.infix(GLSLX.TokenKind.BITWISE_AND, GLSLX.Precedence.BITWISE_AND, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.BITWISE_OR, GLSLX.Precedence.BITWISE_OR, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.BITWISE_XOR, GLSLX.Precedence.BITWISE_XOR, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_ADD, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_ADD));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_AND, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_OR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_XOR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_DIVIDE, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_DIVIDE));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_MULTIPLY, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_MULTIPLY));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_REMAINDER, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_LEFT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SUBTRACT, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_SUBTRACT));\n\n    // Name\n    pratt.literal(GLSLX.TokenKind.IDENTIFIER, function(context, token) {\n      var name = token.range.toString();\n      var symbol = context.scope().find(name);\n\n      if (symbol == null) {\n        context.log.syntaxErrorBadSymbolReference(token.range);\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(token.range);\n      }\n\n      // Check extension usage\n      if (symbol.requiredExtension != null && context.compilationData.extensionBehavior(symbol.requiredExtension) == GLSLX.ExtensionBehavior.DISABLE) {\n        context.log.syntaxErrorDisabledExtension(token.range, name, symbol.requiredExtension);\n      }\n\n      return (symbol.isStruct() ? new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()) : new GLSLX.Node(GLSLX.NodeKind.NAME).withSymbol(symbol)).withRange(token.range);\n    });\n\n    // Sequence\n    pratt.infix(GLSLX.TokenKind.COMMA, GLSLX.Precedence.COMMA, function(context, left, token, right) {\n      if (left.kind != GLSLX.NodeKind.SEQUENCE) {\n        left = new GLSLX.Node(GLSLX.NodeKind.SEQUENCE).appendChild(left).withRange(left.range);\n      }\n\n      left.appendChild(right);\n      return left.withRange(context.spanSince(left.range));\n    });\n\n    // Dot\n    pratt.parselet(GLSLX.TokenKind.DOT, GLSLX.Precedence.MEMBER).infix = function(context, left) {\n      context.next();\n      var name = context.current().range;\n\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n        return null;\n      }\n\n      return GLSLX.Node.createDot(left, name.toString()).withRange(context.spanSince(left.range)).withInternalRange(name);\n    };\n\n    // Group\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.LOWEST).prefix = function(context) {\n      var token = context.next();\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n\n      return value.withRange(context.spanSince(token.range));\n    };\n\n    // Call\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.UNARY_POSTFIX).infix = function(context, left) {\n      var token = context.next();\n      var node = GLSLX.Node.createCall(left);\n\n      if (!GLSLX.Parser.parseCommaSeparatedList(context, node, GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n\n      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\n    };\n\n    // Index\n    pratt.parselet(GLSLX.TokenKind.LEFT_BRACKET, GLSLX.Precedence.MEMBER).infix = function(context, left) {\n      var token = context.next();\n\n      // The \"[]\" syntax isn't valid but skip over it and recover\n      if (context.peek(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        context.unexpectedToken();\n        context.next();\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(context.spanSince(token.range));\n      }\n\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        return null;\n      }\n\n      return GLSLX.Node.createBinary(GLSLX.NodeKind.INDEX, left, value).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\n    };\n\n    // Hook\n    pratt.parselet(GLSLX.TokenKind.QUESTION, GLSLX.Precedence.ASSIGN).infix = function(context, left) {\n      context.next();\n      var middle = pratt.parse(context, GLSLX.Precedence.COMMA);\n\n      if (middle == null || !context.expect(GLSLX.TokenKind.COLON)) {\n        return null;\n      }\n\n      var right = pratt.parse(context, GLSLX.Precedence.COMMA);\n\n      if (right == null) {\n        return null;\n      }\n\n      return GLSLX.Node.createHook(left, middle, right).withRange(context.spanSince(left.range));\n    };\n    return pratt;\n  };\n\n  GLSLX.Parser.parseCommaSeparatedList = function(context, parent, stop) {\n    var isFirst = true;\n\n    while (!context.eat(stop)) {\n      if (!isFirst && !context.expect(GLSLX.TokenKind.COMMA)) {\n        return false;\n      }\n\n      var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\n\n      if (value == null) {\n        return false;\n      }\n\n      parent.appendChild(value);\n      isFirst = false;\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parseDoWhile = function(context) {\n    var token = context.next();\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (body == null || !context.expect(GLSLX.TokenKind.WHILE) || !context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (test == null) {\n      return null;\n    }\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      return null;\n    }\n\n    context.popScope();\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createDoWhile(body, test));\n  };\n\n  GLSLX.Parser.parseExportOrImport = function(context) {\n    var token = context.next();\n    var old = context.flags;\n    context.flags |= token.kind == GLSLX.TokenKind.EXPORT ? GLSLX.SymbolFlags.EXPORTED : GLSLX.SymbolFlags.IMPORTED;\n\n    // Parse a modifier block\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\n      var node = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\n\n      if (!GLSLX.Parser.parseStatements(context, node, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n        return null;\n      }\n\n      context.flags = old;\n      return node.withRange(context.spanSince(token.range));\n    }\n\n    // Just parse a single statement\n    var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.GLOBAL);\n\n    if (statement == null) {\n      return null;\n    }\n\n    context.flags = old;\n    return statement;\n  };\n\n  GLSLX.Parser.parseExtension = function(context) {\n    var token = context.next();\n    var range = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n      return null;\n    }\n\n    var name = range.toString();\n\n    // Parse an extension block (a non-standard addition)\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\n      if (!(name in context.compilationData.currentExtensions)) {\n        // Silence warnings about this name\n        context.compilationData.currentExtensions[name] = GLSLX.ExtensionBehavior.DEFAULT;\n      }\n\n      var block = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\n\n      if (!GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n        return null;\n      }\n\n      for (var child = block.firstChild(); child != null; child = child.nextSibling()) {\n        if (child.kind == GLSLX.NodeKind.VARIABLES) {\n          for (var variable = child.variablesType().nextSibling(); variable != null; variable = variable.nextSibling()) {\n            variable.symbol.requiredExtension = name;\n          }\n        }\n\n        else if (child.symbol != null) {\n          child.symbol.requiredExtension = name;\n        }\n      }\n\n      return block.withRange(context.spanSince(token.range));\n    }\n\n    // Warn about typos\n    if (!(name in GLSLX.Parser._knownWebGLExtensions) && !(name in context.compilationData.currentExtensions)) {\n      context.log.syntaxWarningUnknownExtension(range, name);\n    }\n\n    // Parse a regular extension pragma\n    if (!context.expect(GLSLX.TokenKind.COLON)) {\n      return null;\n    }\n\n    var text = context.current().range.toString();\n\n    if (!(text in GLSLX.Parser._extensionBehaviors)) {\n      context.unexpectedToken();\n      return null;\n    }\n\n    context.next();\n\n    // Activate or deactivate the extension\n    var behavior = in_StringMap.get1(GLSLX.Parser._extensionBehaviors, text);\n    context.compilationData.currentExtensions[name] = behavior;\n    return new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(behavior).withRange(context.spanSince(token.range)).withInternalRange(range);\n  };\n\n  GLSLX.Parser.parseFor = function(context) {\n    var token = context.next();\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    // Setup\n    var setup = null;\n\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\n      // Check for a type\n      var flags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.LOCAL);\n      var type = null;\n\n      if (flags != 0) {\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n        if (type == null) {\n          return null;\n        }\n      }\n\n      else {\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\n      }\n\n      // Try to parse a variable\n      if (type != null) {\n        setup = GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.AVOID_FUNCTIONS);\n\n        if (setup == null) {\n          return null;\n        }\n      }\n\n      else {\n        setup = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n        if (setup == null) {\n          return null;\n        }\n\n        if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\n          return null;\n        }\n      }\n    }\n\n    // Test\n    var test = null;\n\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\n      test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (test == null) {\n        return null;\n      }\n\n      if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\n        return null;\n      }\n    }\n\n    // Update\n    var update = null;\n\n    if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      update = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (update == null) {\n        return null;\n      }\n\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n    }\n\n    // Body\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (body == null) {\n      return null;\n    }\n\n    context.popScope();\n    return GLSLX.Node.createFor(setup, test, update, body).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseIf = function(context) {\n    var token = context.next();\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (test == null) {\n      return null;\n    }\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      return null;\n    }\n\n    var yes = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (yes == null) {\n      return null;\n    }\n\n    var no = null;\n\n    if (context.eat(GLSLX.TokenKind.ELSE)) {\n      no = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n      if (no == null) {\n        return null;\n      }\n    }\n\n    return GLSLX.Node.createIf(test, yes, no).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseVersion = function(context) {\n    var token = context.next();\n    var range = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.INT_LITERAL)) {\n      return null;\n    }\n\n    return new GLSLX.Node(GLSLX.NodeKind.VERSION).withInt(range.toString() | 0).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseWhile = function(context) {\n    var token = context.next();\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (test == null) {\n      return null;\n    }\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      return null;\n    }\n\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (body == null) {\n      return null;\n    }\n\n    context.popScope();\n    return GLSLX.Node.createWhile(test, body).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseReturn = function(context) {\n    var token = context.next();\n    var value = null;\n\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\n      value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (value == null) {\n        return null;\n      }\n\n      context.expect(GLSLX.TokenKind.SEMICOLON);\n    }\n\n    return GLSLX.Node.createReturn(value).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parsePrecision = function(context) {\n    var token = context.next();\n    var flag = 0;\n\n    switch (context.current().kind) {\n      case GLSLX.TokenKind.LOWP: {\n        flag = GLSLX.SymbolFlags.LOWP;\n        break;\n      }\n\n      case GLSLX.TokenKind.MEDIUMP: {\n        flag = GLSLX.SymbolFlags.MEDIUMP;\n        break;\n      }\n\n      case GLSLX.TokenKind.HIGHP: {\n        flag = GLSLX.SymbolFlags.HIGHP;\n        break;\n      }\n\n      default: {\n        context.unexpectedToken();\n        return null;\n      }\n    }\n\n    context.next();\n    var type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n    if (type == null) {\n      return null;\n    }\n\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createPrecision(flag, type));\n  };\n\n  GLSLX.Parser.parseStruct = function(context, flags) {\n    var name = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n      return null;\n    }\n\n    var symbol = new GLSLX.StructSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.STRUCT, context.scope()));\n    symbol.flags |= context.flags | flags;\n\n    if (!GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol)) {\n      return null;\n    }\n\n    var range = context.current().range;\n    var block = new GLSLX.Node(GLSLX.NodeKind.STRUCT_BLOCK);\n    var variables = null;\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE)) {\n      return null;\n    }\n\n    context.pushScope(symbol.scope);\n\n    while (!context.peek(GLSLX.TokenKind.RIGHT_BRACE) && !context.peek(GLSLX.TokenKind.END_OF_FILE)) {\n      var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.STRUCT);\n\n      if (statement == null) {\n        return null;\n      }\n\n      if (statement.kind != GLSLX.NodeKind.VARIABLES) {\n        context.log.syntaxErrorInsideStruct(statement.range);\n        continue;\n      }\n\n      block.appendChild(statement);\n\n      for (var child = statement.variablesType().nextSibling(); child != null; child = child.nextSibling()) {\n        var variable = child.symbol.asVariable();\n        symbol.variables.push(variable);\n\n        if (variable.value != null) {\n          context.log.syntaxErrorStructVariableInitializer(variable.value.range);\n        }\n      }\n    }\n\n    context.popScope();\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n      return null;\n    }\n\n    block.withRange(context.spanSince(range));\n\n    // Parse weird struct-variable hybrid things\n    //\n    //   struct S { int x; } y, z[2];\n    //\n    if (context.peek(GLSLX.TokenKind.IDENTIFIER)) {\n      variables = GLSLX.Parser.parseVariables(0, new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()), context.next().range, context);\n\n      if (variables == null) {\n        return null;\n      }\n    }\n\n    else {\n      context.expect(GLSLX.TokenKind.SEMICOLON);\n    }\n\n    return GLSLX.Node.createStruct(symbol, block, variables);\n  };\n\n  GLSLX.Parser.checkForLoopAndSemicolon = function(context, range, node) {\n    var found = false;\n\n    for (var scope = context.scope(); scope != null; scope = scope.parent) {\n      if (scope.kind == GLSLX.ScopeKind.LOOP) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      context.log.syntaxErrorOutsideLoop(range);\n    }\n\n    return GLSLX.Parser.checkForSemicolon(context, range, node);\n  };\n\n  GLSLX.Parser.checkForSemicolon = function(context, range, node) {\n    context.expect(GLSLX.TokenKind.SEMICOLON);\n    return node.withRange(context.spanSince(range));\n  };\n\n  GLSLX.Parser.parseAfterType = function(context, range, flags, type, allow) {\n    var name = context.current().range;\n\n    if (flags == 0 && !context.peek(GLSLX.TokenKind.IDENTIFIER)) {\n      var value = GLSLX.Parser.pratt.resume(context, GLSLX.Precedence.LOWEST, type);\n\n      if (value == null) {\n        return null;\n      }\n\n      return GLSLX.Parser.checkForSemicolon(context, range, GLSLX.Node.createExpression(value));\n    }\n\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n      return null;\n    }\n\n    if (context.eat(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return GLSLX.Parser.parseFunction(flags, type, name, context);\n    }\n\n    var variables = GLSLX.Parser.parseVariables(flags, type, name, context);\n\n    if (variables == null) {\n      return null;\n    }\n\n    return variables.withRange(context.spanSince(range));\n  };\n\n  GLSLX.Parser.parseStatement = function(context, mode) {\n    var token = context.current();\n\n    switch (token.kind) {\n      case GLSLX.TokenKind.BREAK: {\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.BREAK));\n      }\n\n      case GLSLX.TokenKind.CONTINUE: {\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.CONTINUE));\n      }\n\n      case GLSLX.TokenKind.DISCARD: {\n        return GLSLX.Parser.checkForSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.DISCARD));\n      }\n\n      case GLSLX.TokenKind.DO: {\n        return GLSLX.Parser.parseDoWhile(context);\n      }\n\n      case GLSLX.TokenKind.EXPORT:\n      case GLSLX.TokenKind.IMPORT: {\n        return GLSLX.Parser.parseExportOrImport(context);\n      }\n\n      case GLSLX.TokenKind.EXTENSION: {\n        return GLSLX.Parser.parseExtension(context);\n      }\n\n      case GLSLX.TokenKind.FOR: {\n        return GLSLX.Parser.parseFor(context);\n      }\n\n      case GLSLX.TokenKind.IF: {\n        return GLSLX.Parser.parseIf(context);\n      }\n\n      case GLSLX.TokenKind.LEFT_BRACE: {\n        return GLSLX.Parser.parseBlock(context);\n      }\n\n      case GLSLX.TokenKind.PRECISION: {\n        return GLSLX.Parser.parsePrecision(context);\n      }\n\n      case GLSLX.TokenKind.RETURN: {\n        return GLSLX.Parser.parseReturn(context);\n      }\n\n      case GLSLX.TokenKind.SEMICOLON: {\n        return new GLSLX.Node(GLSLX.NodeKind.BLOCK).withRange(context.next().range);\n      }\n\n      case GLSLX.TokenKind.VERSION: {\n        return GLSLX.Parser.parseVersion(context);\n      }\n\n      case GLSLX.TokenKind.WHILE: {\n        return GLSLX.Parser.parseWhile(context);\n      }\n    }\n\n    // Try to parse a variable or function\n    var flags = GLSLX.Parser.parseFlags(context, mode);\n    var type = null;\n\n    if (context.eat(GLSLX.TokenKind.STRUCT)) {\n      var struct = GLSLX.Parser.parseStruct(context, flags);\n\n      if (struct == null) {\n        return null;\n      }\n\n      return struct.withRange(context.spanSince(token.range));\n    }\n\n    if (flags != 0) {\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n      if (type == null) {\n        return null;\n      }\n    }\n\n    else {\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\n    }\n\n    if (type != null) {\n      return GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.ALLOW_FUNCTIONS);\n    }\n\n    // Parse an expression\n    var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (value == null) {\n      return null;\n    }\n\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createExpression(value));\n  };\n\n  GLSLX.Parser.checkStatementLocation = function(context, node) {\n    if (node.kind == GLSLX.NodeKind.VARIABLES || node.kind == GLSLX.NodeKind.STRUCT) {\n      return;\n    }\n\n    var isOutsideFunction = context.scope().kind == GLSLX.ScopeKind.GLOBAL || context.scope().kind == GLSLX.ScopeKind.STRUCT;\n    var shouldBeOutsideFunction = node.kind == GLSLX.NodeKind.EXTENSION || node.kind == GLSLX.NodeKind.FUNCTION || node.kind == GLSLX.NodeKind.PRECISION || node.kind == GLSLX.NodeKind.VERSION;\n\n    if (shouldBeOutsideFunction && !isOutsideFunction) {\n      context.log.syntaxErrorInsideFunction(node.range);\n    }\n\n    else if (!shouldBeOutsideFunction && isOutsideFunction) {\n      context.log.syntaxErrorOutsideFunction(node.range);\n    }\n  };\n\n  GLSLX.Parser.parseInclude = function(context, parent) {\n    // See if there is a string literal\n    var range = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.STRING_LITERAL)) {\n      return false;\n    }\n\n    // Decode the escapes\n    var path = null;\n\n    try {\n      path = JSON.parse(range.toString());\n    }\n\n    catch (e) {\n      context.log.syntaxErrorInvalidString(range);\n      return false;\n    }\n\n    // Must have access to the file system\n    var fileAccess = context.compilationData.fileAccess;\n\n    if (fileAccess == null) {\n      context.log.semanticErrorIncludeWithoutFileAccess(range);\n      return false;\n    }\n\n    // Must be able to read the file\n    var source = fileAccess(path, range.source.name);\n\n    if (source == null) {\n      context.log.semanticErrorIncludeBadPath(range, path);\n      return false;\n    }\n\n    // Parse the file and insert it into the parent\n    var tokens = GLSLX.Tokenizer.tokenize(context.log, source);\n    var nestedContext = new GLSLX.ParserContext(context.log, tokens, context.compilationData, context.resolver);\n    nestedContext.pushScope(context.scope());\n\n    if (!GLSLX.Parser.parseStatements(nestedContext, parent, GLSLX.VariableKind.GLOBAL) || !nestedContext.expect(GLSLX.TokenKind.END_OF_FILE)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parseBlock = function(context) {\n    var token = context.current();\n    var block = new GLSLX.Node(GLSLX.NodeKind.BLOCK);\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOCAL, context.scope()));\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE) || !GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.LOCAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n      return null;\n    }\n\n    context.popScope();\n    return block.withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseFlags = function(context, mode) {\n    var flags = 0;\n\n    while (true) {\n      var kind = context.current().kind;\n\n      switch (kind) {\n        case GLSLX.TokenKind.ATTRIBUTE: {\n          flags |= GLSLX.SymbolFlags.ATTRIBUTE;\n          break;\n        }\n\n        case GLSLX.TokenKind.CONST: {\n          flags |= GLSLX.SymbolFlags.CONST;\n          break;\n        }\n\n        case GLSLX.TokenKind.HIGHP: {\n          flags |= GLSLX.SymbolFlags.HIGHP;\n          break;\n        }\n\n        case GLSLX.TokenKind.IN: {\n          flags |= GLSLX.SymbolFlags.IN;\n          break;\n        }\n\n        case GLSLX.TokenKind.INOUT: {\n          flags |= GLSLX.SymbolFlags.INOUT;\n          break;\n        }\n\n        case GLSLX.TokenKind.LOWP: {\n          flags |= GLSLX.SymbolFlags.LOWP;\n          break;\n        }\n\n        case GLSLX.TokenKind.MEDIUMP: {\n          flags |= GLSLX.SymbolFlags.MEDIUMP;\n          break;\n        }\n\n        case GLSLX.TokenKind.OUT: {\n          flags |= GLSLX.SymbolFlags.OUT;\n          break;\n        }\n\n        case GLSLX.TokenKind.UNIFORM: {\n          flags |= GLSLX.SymbolFlags.UNIFORM;\n          break;\n        }\n\n        case GLSLX.TokenKind.VARYING: {\n          flags |= GLSLX.SymbolFlags.VARYING;\n          break;\n        }\n\n        default: {\n          return flags;\n        }\n      }\n\n      if (mode == GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.ATTRIBUTE || kind == GLSLX.TokenKind.UNIFORM || kind == GLSLX.TokenKind.VARYING) || mode == GLSLX.VariableKind.STRUCT && kind != GLSLX.TokenKind.LOWP && kind != GLSLX.TokenKind.MEDIUMP && kind != GLSLX.TokenKind.HIGHP || mode != GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.IN || kind == GLSLX.TokenKind.OUT || kind == GLSLX.TokenKind.INOUT)) {\n        context.log.syntaxErrorBadQualifier(context.current().range);\n      }\n\n      context.next();\n    }\n  };\n\n  GLSLX.Parser.parseType = function(context, mode) {\n    var token = context.current();\n    var type = null;\n\n    switch (token.kind) {\n      case GLSLX.TokenKind.BOOL: {\n        type = GLSLX.Type.BOOL;\n        break;\n      }\n\n      case GLSLX.TokenKind.BVEC2: {\n        type = GLSLX.Type.BVEC2;\n        break;\n      }\n\n      case GLSLX.TokenKind.BVEC3: {\n        type = GLSLX.Type.BVEC3;\n        break;\n      }\n\n      case GLSLX.TokenKind.BVEC4: {\n        type = GLSLX.Type.BVEC4;\n        break;\n      }\n\n      case GLSLX.TokenKind.FLOAT: {\n        type = GLSLX.Type.FLOAT;\n        break;\n      }\n\n      case GLSLX.TokenKind.INT: {\n        type = GLSLX.Type.INT;\n        break;\n      }\n\n      case GLSLX.TokenKind.IVEC2: {\n        type = GLSLX.Type.IVEC2;\n        break;\n      }\n\n      case GLSLX.TokenKind.IVEC3: {\n        type = GLSLX.Type.IVEC3;\n        break;\n      }\n\n      case GLSLX.TokenKind.IVEC4: {\n        type = GLSLX.Type.IVEC4;\n        break;\n      }\n\n      case GLSLX.TokenKind.MAT2: {\n        type = GLSLX.Type.MAT2;\n        break;\n      }\n\n      case GLSLX.TokenKind.MAT3: {\n        type = GLSLX.Type.MAT3;\n        break;\n      }\n\n      case GLSLX.TokenKind.MAT4: {\n        type = GLSLX.Type.MAT4;\n        break;\n      }\n\n      case GLSLX.TokenKind.SAMPLER2D: {\n        type = GLSLX.Type.SAMPLER2D;\n        break;\n      }\n\n      case GLSLX.TokenKind.SAMPLERCUBE: {\n        type = GLSLX.Type.SAMPLERCUBE;\n        break;\n      }\n\n      case GLSLX.TokenKind.VEC2: {\n        type = GLSLX.Type.VEC2;\n        break;\n      }\n\n      case GLSLX.TokenKind.VEC3: {\n        type = GLSLX.Type.VEC3;\n        break;\n      }\n\n      case GLSLX.TokenKind.VEC4: {\n        type = GLSLX.Type.VEC4;\n        break;\n      }\n\n      case GLSLX.TokenKind.VOID: {\n        type = GLSLX.Type.VOID;\n        break;\n      }\n\n      case GLSLX.TokenKind.IDENTIFIER: {\n        var symbol = context.scope().find(token.range.toString());\n\n        if (symbol == null || !symbol.isStruct()) {\n          if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\n            context.unexpectedToken();\n          }\n\n          return null;\n        }\n\n        type = symbol.resolvedType();\n        break;\n      }\n\n      default: {\n        if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\n          context.unexpectedToken();\n        }\n\n        return null;\n      }\n    }\n\n    context.next();\n    return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseFunction = function(flags, type, name, context) {\n    var originalScope = context.scope();\n    var $function = new GLSLX.FunctionSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.FUNCTION, originalScope));\n    $function.flags |= context.flags | flags | ($function.name == 'main' ? GLSLX.SymbolFlags.EXPORTED : 0);\n    $function.returnType = type;\n    context.pushScope($function.scope);\n\n    // Takes no arguments\n    if (context.eat(GLSLX.TokenKind.VOID)) {\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n    }\n\n    // Takes arguments\n    else if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      while (true) {\n        // Parse leading flags\n        var argumentFlags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.ARGUMENT);\n\n        // Parse the type\n        var argumentType = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n        if (argumentType == null) {\n          return null;\n        }\n\n        // Parse the identifier\n        var argumentName = context.current().range;\n\n        if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n          return null;\n        }\n\n        // Create the argument\n        var argument = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), argumentName, argumentName.toString(), context.scope(), GLSLX.VariableKind.ARGUMENT);\n        argument.flags |= argumentFlags;\n        argument.type = argumentType;\n        $function.$arguments.push(argument);\n        GLSLX.Parser.tryToDefineUniquelyInScope(context, argument);\n\n        // Array size\n        if (!GLSLX.Parser.parseArraySize(context, argument)) {\n          return null;\n        }\n\n        // Parse another argument?\n        if (!context.eat(GLSLX.TokenKind.COMMA)) {\n          break;\n        }\n      }\n\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n    }\n\n    var previous = in_StringMap.get(originalScope.symbols, name.toString(), null);\n    var hasBlock = !context.eat(GLSLX.TokenKind.SEMICOLON);\n\n    // Merge adjacent function symbols to support overloading\n    if (previous == null) {\n      originalScope.define($function);\n    }\n\n    else if (previous.isFunction()) {\n      for (var link = previous.asFunction(); link != null; link = link.previousOverload) {\n        if (!link.hasSameArgumentTypesAs($function)) {\n          continue;\n        }\n\n        // Overloading by return type is not allowed\n        if (link.returnType.resolvedType != $function.returnType.resolvedType) {\n          context.log.syntaxErrorDifferentReturnType($function.returnType.range, $function.name, $function.returnType.resolvedType, link.returnType.resolvedType, link.returnType.range);\n        }\n\n        // Defining a function more than once is not allowed\n        else if (link.block != null || !hasBlock) {\n          context.log.syntaxErrorDuplicateSymbolDefinition($function.range, link.range);\n        }\n\n        // Merge the function with its forward declaration\n        else {\n          assert(link.sibling == null);\n          assert($function.sibling == null);\n          link.sibling = $function;\n          $function.sibling = link;\n          $function.flags |= link.flags;\n          link.flags = $function.flags;\n        }\n\n        break;\n      }\n\n      // Use a singly-linked list to store the function overloads\n      $function.previousOverload = previous.asFunction();\n      originalScope.redefine($function);\n    }\n\n    else {\n      context.log.syntaxErrorDuplicateSymbolDefinition(name, previous.range);\n      return null;\n    }\n\n    if (hasBlock) {\n      var old = context.flags;\n      context.flags &= ~(GLSLX.SymbolFlags.EXPORTED | GLSLX.SymbolFlags.IMPORTED);\n      $function.block = GLSLX.Parser.parseBlock(context);\n      context.flags &= old;\n\n      if ($function.block == null) {\n        return null;\n      }\n    }\n\n    context.popScope();\n    return new GLSLX.Node(GLSLX.NodeKind.FUNCTION).withSymbol($function).withRange(context.spanSince(type.range));\n  };\n\n  GLSLX.Parser.parseArraySize = function(context, variable) {\n    var token = context.current();\n\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACKET)) {\n      // The \"[]\" syntax isn't valid but skip over it and recover\n      if (context.eat(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        context.log.syntaxErrorMissingArraySize(context.spanSince(token.range));\n        return true;\n      }\n\n      variable.arrayCount = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (variable.arrayCount == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        return false;\n      }\n\n      // The array size must be resolved immediately\n      var count = 0;\n      context.resolver.resolveNode(variable.arrayCount);\n      context.resolver.checkConversion(variable.arrayCount, GLSLX.Type.INT);\n\n      if (variable.arrayCount.resolvedType != GLSLX.Type.ERROR) {\n        var folded = GLSLX.Folder.fold(variable.arrayCount);\n\n        if (folded == null) {\n          context.log.syntaxErrorConstantRequired(variable.arrayCount.range);\n        }\n\n        else if (folded.kind == GLSLX.NodeKind.INT) {\n          var value = folded.asInt();\n\n          if (value < 1) {\n            context.log.syntaxErrorInvalidArraySize(variable.arrayCount.range, value);\n          }\n\n          else {\n            count = value;\n          }\n        }\n      }\n\n      // Multidimensional arrays are not supported\n      while (context.peek(GLSLX.TokenKind.LEFT_BRACKET)) {\n        token = context.next();\n\n        if (!context.peek(GLSLX.TokenKind.RIGHT_BRACKET) && GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST) == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\n          return false;\n        }\n\n        context.log.syntaxErrorMultidimensionalArray(context.spanSince(token.range));\n      }\n\n      variable.type = new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(variable.type.resolvedType.arrayType(count)).withRange(variable.type.range);\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parseVariables = function(flags, type, name, context) {\n    var variables = GLSLX.Node.createVariables(context.flags | flags, type);\n\n    while (true) {\n      var symbol = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), name, name.toString(), context.scope(), context.scope().kind == GLSLX.ScopeKind.GLOBAL ? GLSLX.VariableKind.GLOBAL : context.scope().kind == GLSLX.ScopeKind.STRUCT ? GLSLX.VariableKind.STRUCT : GLSLX.VariableKind.LOCAL);\n      symbol.flags |= context.flags | flags;\n      symbol.type = type;\n\n      // Array size\n      if (!GLSLX.Parser.parseArraySize(context, symbol)) {\n        return null;\n      }\n\n      // Initial value\n      var assign = context.current().range;\n\n      if (context.eat(GLSLX.TokenKind.ASSIGN)) {\n        symbol.value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\n\n        if (symbol.value == null) {\n          return null;\n        }\n      }\n\n      else {\n        assign = null;\n      }\n\n      // Constants must be resolved immediately\n      var variable = new GLSLX.Node(GLSLX.NodeKind.VARIABLE).withSymbol(symbol).withRange(context.spanSince(symbol.range)).withInternalRange(assign);\n\n      if (symbol.isConst()) {\n        context.resolver.resolveNode(variable);\n      }\n\n      variables.appendChild(variable);\n      GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol);\n\n      // Are there more variables in this statement?\n      if (!context.eat(GLSLX.TokenKind.COMMA)) {\n        context.expect(GLSLX.TokenKind.SEMICOLON);\n        return variables;\n      }\n\n      name = context.current().range;\n\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n        return null;\n      }\n    }\n  };\n\n  GLSLX.Parser.tryToDefineUniquelyInScope = function(context, symbol) {\n    var previous = in_StringMap.get(context.scope().symbols, symbol.name, null);\n\n    if (previous != null) {\n      context.log.syntaxErrorDuplicateSymbolDefinition(symbol.range, previous.range);\n      return false;\n    }\n\n    context.scope().define(symbol);\n    return true;\n  };\n\n  GLSLX.Parser.parseStatements = function(context, parent, mode) {\n    while (!context.peek(GLSLX.TokenKind.END_OF_FILE) && !context.peek(GLSLX.TokenKind.RIGHT_BRACE)) {\n      if (context.eat(GLSLX.TokenKind.INCLUDE)) {\n        if (!GLSLX.Parser.parseInclude(context, parent)) {\n          return false;\n        }\n\n        continue;\n      }\n\n      var statement = GLSLX.Parser.parseStatement(context, mode);\n\n      if (statement == null) {\n        return false;\n      }\n\n      // Extension blocks are temporary and don't exist in the parsed result\n      if (statement.kind == GLSLX.NodeKind.MODIFIER_BLOCK) {\n        while (statement.hasChildren()) {\n          var child = statement.firstChild().remove();\n          GLSLX.Parser.checkStatementLocation(context, child);\n          parent.appendChild(child);\n        }\n      }\n\n      else {\n        GLSLX.Parser.checkStatementLocation(context, statement);\n        parent.appendChild(statement);\n      }\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parse = function(log, tokens, global, data, scope, resolver) {\n    if (GLSLX.Parser.pratt == null) {\n      GLSLX.Parser.pratt = GLSLX.Parser.createExpressionParser();\n    }\n\n    var context = new GLSLX.ParserContext(log, tokens, data, resolver);\n    context.pushScope(scope);\n\n    if (GLSLX.Parser.parseStatements(context, global, GLSLX.VariableKind.GLOBAL)) {\n      context.expect(GLSLX.TokenKind.END_OF_FILE);\n    }\n  };\n\n  GLSLX.Parser.Allow = {\n    AVOID_FUNCTIONS: 0,\n    ALLOW_FUNCTIONS: 1\n  };\n\n  GLSLX.Parser.ParseTypeMode = {\n    IGNORE_ERRORS: 0,\n    REPORT_ERRORS: 1\n  };\n\n  // The same operator precedence as C for the most part\n  GLSLX.Precedence = {\n    LOWEST: 0,\n    COMMA: 1,\n    ASSIGN: 2,\n    LOGICAL_OR: 3,\n    LOGICAL_XOR: 4,\n    LOGICAL_AND: 5,\n    BITWISE_OR: 6,\n    BITWISE_XOR: 7,\n    BITWISE_AND: 8,\n    COMPARE: 10,\n    SHIFT: 11,\n    ADD: 12,\n    MULTIPLY: 13,\n    UNARY_PREFIX: 14,\n    UNARY_POSTFIX: 15,\n    MEMBER: 16\n  };\n\n  GLSLX.ParserContext = function(log, _tokens, compilationData, resolver) {\n    this.log = log;\n    this._tokens = _tokens;\n    this.compilationData = compilationData;\n    this.resolver = resolver;\n    this.flags = 0;\n    this._index = 0;\n    this._scope = null;\n  };\n\n  GLSLX.ParserContext.prototype.current = function() {\n    return in_List.get(this._tokens, this._index);\n  };\n\n  GLSLX.ParserContext.prototype.next = function() {\n    var token = this.current();\n\n    if ((this._index + 1 | 0) < this._tokens.length) {\n      this._index = this._index + 1 | 0;\n    }\n\n    return token;\n  };\n\n  GLSLX.ParserContext.prototype.spanSince = function(range) {\n    var previous = in_List.get(this._tokens, this._index > 0 ? this._index - 1 | 0 : 0);\n    return previous.range.end < range.start ? range : GLSLX.Range.span(range, previous.range);\n  };\n\n  GLSLX.ParserContext.prototype.peek = function(kind) {\n    return this.current().kind == kind;\n  };\n\n  GLSLX.ParserContext.prototype.eat = function(kind) {\n    if (this.peek(kind)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  };\n\n  GLSLX.ParserContext.prototype.expect = function(kind) {\n    if (this.eat(kind)) {\n      return true;\n    }\n\n    var token = this.current();\n    var range = token.range;\n    var previous = (this._index > 0 ? in_List.get(this._tokens, this._index - 1 | 0) : token).range;\n\n    // Put errors about missing semicolons and about tokens on the next line\n    // after the previous token instead of at the next token\n    if (kind == GLSLX.TokenKind.SEMICOLON || previous.lineColumn().line != range.lineColumn().line) {\n      this.log.syntaxErrorExpectedToken1(previous.rangeAtEnd(), kind);\n    }\n\n    else {\n      this.log.syntaxErrorExpectedToken2(range, token.kind, kind);\n    }\n\n    return false;\n  };\n\n  GLSLX.ParserContext.prototype.unexpectedToken = function() {\n    this.log.syntaxErrorUnexpectedToken(this.current());\n  };\n\n  GLSLX.ParserContext.prototype.scope = function() {\n    return this._scope;\n  };\n\n  GLSLX.ParserContext.prototype.pushScope = function(newScope) {\n    assert(newScope.parent == this._scope);\n    this._scope = newScope;\n  };\n\n  GLSLX.ParserContext.prototype.popScope = function() {\n    assert(this._scope != null);\n    this._scope = this._scope.parent;\n  };\n\n  GLSLX.Parselet = function(precedence) {\n    this.precedence = precedence;\n    this.prefix = null;\n    this.infix = null;\n  };\n\n  // A Pratt parser is a parser that associates up to two operations per token,\n  // each with its own precedence. Pratt parsers excel at parsing expression\n  // trees with deeply nested precedence levels. For an excellent writeup, see:\n  //\n  //   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  //\n  GLSLX.Pratt = function() {\n    this._table = {};\n  };\n\n  GLSLX.Pratt.prototype.parselet = function(kind, precedence) {\n    var parselet = in_IntMap.get(this._table, kind, null);\n\n    if (parselet == null) {\n      var created = new GLSLX.Parselet(precedence);\n      parselet = created;\n      this._table[kind] = created;\n    }\n\n    else if (precedence > parselet.precedence) {\n      parselet.precedence = precedence;\n    }\n\n    return parselet;\n  };\n\n  GLSLX.Pratt.prototype.parse = function(context, precedence) {\n    var token = context.current();\n    var parselet = in_IntMap.get(this._table, token.kind, null);\n\n    if (parselet == null || parselet.prefix == null) {\n      context.unexpectedToken();\n      return null;\n    }\n\n    var node = this.resume(context, precedence, parselet.prefix(context));\n\n    // Parselets must set the range of every node\n    assert(node == null || node.range != null);\n    return node;\n  };\n\n  GLSLX.Pratt.prototype.resume = function(context, precedence, left) {\n    while (left != null) {\n      var kind = context.current().kind;\n      var parselet = in_IntMap.get(this._table, kind, null);\n\n      if (parselet == null || parselet.infix == null || parselet.precedence <= precedence) {\n        break;\n      }\n\n      left = parselet.infix(context, left);\n\n      // Parselets must set the range of every node\n      assert(left == null || left.range != null);\n    }\n\n    return left;\n  };\n\n  GLSLX.Pratt.prototype.literal = function(kind, callback) {\n    this.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\n      return callback(context, context.next());\n    };\n  };\n\n  GLSLX.Pratt.prototype.prefix = function(kind, precedence, callback) {\n    var self = this;\n    self.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\n      var token = context.next();\n      var value = self.parse(context, precedence);\n      return value != null ? callback(context, token, value) : null;\n    };\n  };\n\n  GLSLX.Pratt.prototype.postfix = function(kind, precedence, callback) {\n    this.parselet(kind, precedence).infix = function(context, left) {\n      return callback(context, left, context.next());\n    };\n  };\n\n  GLSLX.Pratt.prototype.infix = function(kind, precedence, callback) {\n    var self = this;\n    self.parselet(kind, precedence).infix = function(context, left) {\n      var token = context.next();\n      var right = self.parse(context, precedence);\n      return right != null ? callback(context, left, token, right) : null;\n    };\n  };\n\n  GLSLX.Pratt.prototype.infixRight = function(kind, precedence, callback) {\n    var self = this;\n    self.parselet(kind, precedence).infix = function(context, left) {\n      var token = context.next();\n\n      // Subtract 1 for right-associativity\n      var right = self.parse(context, precedence - 1 | 0);\n      return right != null ? callback(context, left, token, right) : null;\n    };\n  };\n\n  GLSLX.Range = function(source, start, end) {\n    this.source = source;\n    this.start = start;\n    this.end = end;\n  };\n\n  GLSLX.Range.prototype.toString = function() {\n    return in_string.slice2(this.source.contents, this.start, this.end);\n  };\n\n  GLSLX.Range.prototype.slice = function(offsetStart, offsetEnd) {\n    assert(offsetStart >= 0 && offsetStart <= offsetEnd && offsetEnd <= (this.end - this.start | 0));\n    return new GLSLX.Range(this.source, this.start + offsetStart | 0, this.start + offsetEnd | 0);\n  };\n\n  GLSLX.Range.prototype.lineColumn = function() {\n    return this.source.indexToLineColumn(this.start);\n  };\n\n  GLSLX.Range.prototype.rangeAtEnd = function() {\n    return new GLSLX.Range(this.source, this.end, this.end);\n  };\n\n  GLSLX.Range.span = function(start, end) {\n    assert(start.source == end.source);\n    assert(start.start <= end.end);\n    return new GLSLX.Range(start.source, start.start, end.end);\n  };\n\n  GLSLX.Resolver = function(_log, _data) {\n    this._log = _log;\n    this._data = _data;\n    this._controlFlow = new GLSLX.ControlFlowAnalyzer();\n    this._versions = [];\n    this._generatedExtensions = Object.create(null);\n    this._returnType = null;\n  };\n\n  GLSLX.Resolver.prototype.resolveGlobal = function(global) {\n    this.resolveNode(global);\n\n    // Remove all version statements\n    for (var i = 0, list = this._versions, count = list.length; i < count; i = i + 1 | 0) {\n      var version = in_List.get(list, i);\n      version.remove();\n    }\n\n    // Re-insert the first version statement\n    var first = global.firstChild();\n\n    if (!(this._versions.length == 0)) {\n      global.insertChildBefore(first, in_List.first(this._versions));\n    }\n\n    // Insert all automatically generated extensions\n    for (var i1 = 0, list1 = in_StringMap.values(this._generatedExtensions), count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\n      var extension = in_List.get(list1, i1);\n      global.insertChildBefore(first, extension);\n    }\n  };\n\n  GLSLX.Resolver.prototype.resolveNode = function(node) {\n    if (node.resolvedType != null) {\n      return;\n    }\n\n    node.resolvedType = GLSLX.Type.ERROR;\n    var kind = node.kind;\n\n    switch (kind) {\n      case GLSLX.NodeKind.GLOBAL:\n      case GLSLX.NodeKind.STRUCT_BLOCK: {\n        this._resolveChildren(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.VARIABLE: {\n        var symbol = node.symbol.asVariable();\n        this.resolveNode(symbol.type);\n\n        // Variables must have a type\n        var type = symbol.type.resolvedType;\n\n        if (type == GLSLX.Type.VOID) {\n          this._log.semanticErrorBadVariableType(symbol.type.range, type);\n          type = GLSLX.Type.ERROR;\n        }\n\n        // Array size\n        if (symbol.arrayCount != null) {\n          this._resolveAsExpression(symbol.arrayCount);\n          this.checkConversion(symbol.arrayCount, GLSLX.Type.INT);\n        }\n\n        // Initial value\n        if (symbol.value != null) {\n          this._resolveAsExpression(symbol.value);\n          this.checkConversion(symbol.value, type);\n\n          if (type.containsArray) {\n            this._log.semanticErrorArrayAssignment(node.internalRange, type);\n          }\n        }\n\n        // Constants must be initialized\n        if (symbol.isConst()) {\n          if (symbol.value != null) {\n            if (symbol.value.resolvedType != GLSLX.Type.ERROR) {\n              var folded = GLSLX.Folder.fold(symbol.value);\n\n              if (folded == null) {\n                this._log.syntaxErrorConstantRequired(symbol.value.range);\n              }\n\n              else {\n                assert(folded.parent() == null);\n                assert(folded.resolvedType != null);\n                symbol.constantValue = folded;\n              }\n            }\n          }\n\n          else if (symbol.kind == GLSLX.VariableKind.LOCAL) {\n            this._log.semanticErrorUninitializedConstant(symbol.range);\n          }\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.BLOCK: {\n        this._resolveBlockOrStatement(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.BREAK:\n      case GLSLX.NodeKind.CONTINUE:\n      case GLSLX.NodeKind.DISCARD: {\n        break;\n      }\n\n      case GLSLX.NodeKind.DO_WHILE: {\n        this._resolveBlockOrStatement(node.doWhileBody());\n        this.resolveNode(node.doWhileTest());\n        this.checkConversion(node.doWhileTest(), GLSLX.Type.BOOL);\n        break;\n      }\n\n      case GLSLX.NodeKind.EXPRESSION: {\n        this.resolveNode(node.expressionValue());\n        break;\n      }\n\n      case GLSLX.NodeKind.EXTENSION: {\n        break;\n      }\n\n      case GLSLX.NodeKind.FOR: {\n        if (node.forSetup() != null) {\n          this._resolveAsExpression(node.forSetup());\n        }\n\n        if (node.forTest() != null) {\n          this._resolveAsExpression(node.forTest());\n          this.checkConversion(node.forTest(), GLSLX.Type.BOOL);\n        }\n\n        if (node.forUpdate() != null) {\n          this._resolveAsExpression(node.forUpdate());\n        }\n\n        this._resolveBlockOrStatement(node.forBody());\n        break;\n      }\n\n      case GLSLX.NodeKind.FUNCTION: {\n        var symbol1 = node.symbol.asFunction();\n\n        for (var i = 0, list = symbol1.$arguments, count = list.length; i < count; i = i + 1 | 0) {\n          var argument = in_List.get(list, i);\n          this.resolveNode(argument.type);\n        }\n\n        this.resolveNode(symbol1.returnType);\n\n        if (symbol1.block != null) {\n          this._returnType = symbol1.returnType.resolvedType;\n          this._resolveBlockOrStatement(symbol1.block);\n\n          // Missing a return statement is an error\n          if (this._returnType != GLSLX.Type.VOID && symbol1.block.hasControlFlowAtEnd) {\n            this._log.semanticErrorMissingReturn(symbol1.range, symbol1.name, this._returnType);\n          }\n\n          this._returnType = null;\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.IF: {\n        this.resolveNode(node.ifTest());\n        this.checkConversion(node.ifTest(), GLSLX.Type.BOOL);\n        this._resolveBlockOrStatement(node.ifTrue());\n\n        if (node.ifFalse() != null) {\n          this._resolveBlockOrStatement(node.ifFalse());\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.PRECISION: {\n        break;\n      }\n\n      case GLSLX.NodeKind.RETURN: {\n        if (node.returnValue() != null) {\n          this.resolveNode(node.returnValue());\n          this.checkConversion(node.returnValue(), this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\n        }\n\n        else {\n          node.resolvedType = GLSLX.Type.VOID;\n          this.checkConversion(node, this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.STRUCT: {\n        this._resolveChildren(node);\n\n        // A struct loses operator \"==\" and \"!=\" when it contains a type without those operators\n        var resolvedType = node.symbol.resolvedType();\n\n        for (var i1 = 0, list1 = node.symbol.asStruct().variables, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\n          var variable = in_List.get(list1, i1);\n          var type1 = variable.type.resolvedType;\n\n          if (type1.containsArray) {\n            resolvedType.containsArray = true;\n          }\n\n          if (type1.containsSampler) {\n            resolvedType.containsSampler = true;\n          }\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.VARIABLES: {\n        this._resolveChildren(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.VERSION: {\n        this._versions.push(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.WHILE: {\n        this.resolveNode(node.whileTest());\n        this.checkConversion(node.whileTest(), GLSLX.Type.BOOL);\n        this._resolveBlockOrStatement(node.whileBody());\n        break;\n      }\n\n      case GLSLX.NodeKind.CALL: {\n        this._resolveCall(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.DOT: {\n        this._resolveDot(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.HOOK: {\n        var test = node.hookTest();\n        var no = node.hookFalse();\n        var yes = node.hookTrue();\n        this._resolveAsExpression(test);\n        this.checkConversion(test, GLSLX.Type.BOOL);\n        this._resolveAsExpression(yes);\n        this._resolveAsExpression(no);\n\n        if (yes.resolvedType != no.resolvedType) {\n          this._log.semanticErrorBadHookTypes(GLSLX.Range.span(yes.range, no.range), yes.resolvedType, no.resolvedType);\n        }\n\n        else if (yes.resolvedType.containsArray) {\n          this._log.semanticErrorArrayHook(GLSLX.Range.span(yes.range, no.range), yes.resolvedType);\n        }\n\n        else {\n          node.resolvedType = yes.resolvedType;\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.NAME: {\n        var symbol2 = node.symbol;\n\n        if (symbol2.isVariable()) {\n          this.resolveNode(symbol2.asVariable().type);\n          node.resolvedType = symbol2.asVariable().type.resolvedType;\n        }\n\n        else if (symbol2.isFunction() && !node.isCallTarget()) {\n          this._log.semanticErrorMustCallFunction(node.range, symbol2.name);\n        }\n\n        else {\n          node.resolvedType = symbol2.resolvedType();\n        }\n\n        // Make sure the extension is enabled if it hasn't been specified\n        var name = symbol2.requiredExtension;\n\n        if (name != null && !(name in this._generatedExtensions) && this._data.extensionBehavior(name) == GLSLX.ExtensionBehavior.DEFAULT) {\n          this._generatedExtensions[name] = new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(GLSLX.ExtensionBehavior.ENABLE);\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.SEQUENCE: {\n        for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n          this._resolveAsExpression(child);\n        }\n\n        node.resolvedType = node.lastChild().resolvedType;\n        break;\n      }\n\n      default: {\n        if (GLSLX.in_NodeKind.isUnary(kind)) {\n          this._resolveUnary(node);\n        }\n\n        else if (GLSLX.in_NodeKind.isBinary(kind)) {\n          this._resolveBinary(node);\n        }\n\n        else {\n          assert(false);\n        }\n        break;\n      }\n    }\n\n    assert(node.resolvedType != null);\n  };\n\n  GLSLX.Resolver.prototype._resolveBlockOrStatement = function(node) {\n    assert(GLSLX.in_NodeKind.isStatement(node.kind));\n    this._controlFlow.pushBlock(node);\n\n    if (node.kind == GLSLX.NodeKind.BLOCK) {\n      for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n        this.resolveNode(child);\n        this._controlFlow.visitStatement(child);\n      }\n    }\n\n    else {\n      this.resolveNode(node);\n      this._controlFlow.visitStatement(node);\n    }\n\n    this._controlFlow.popBlock(node);\n  };\n\n  GLSLX.Resolver.prototype._resolveUnary = function(node) {\n    var value = node.unaryValue();\n    this._resolveAsExpression(value);\n\n    if (GLSLX.in_NodeKind.isUnaryAssign(node.kind)) {\n      this._checkStorage(value);\n    }\n\n    var valueType = value.resolvedType;\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.NEGATIVE:\n      case GLSLX.NodeKind.POSITIVE:\n      case GLSLX.NodeKind.PREFIX_DECREMENT:\n      case GLSLX.NodeKind.PREFIX_INCREMENT:\n      case GLSLX.NodeKind.POSTFIX_DECREMENT:\n      case GLSLX.NodeKind.POSTFIX_INCREMENT: {\n        node.resolvedType = valueType.isIntOrFloat() ? valueType : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.NOT: {\n        node.resolvedType = valueType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n    }\n\n    if (node.resolvedType == GLSLX.Type.ERROR && valueType != GLSLX.Type.ERROR) {\n      this._log.semanticErrorBadUnaryOperator(node.internalRange, node.internalRange.toString(), valueType);\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveBinary = function(node) {\n    var left = node.binaryLeft();\n    var right = node.binaryRight();\n    this._resolveAsExpression(left);\n    this._resolveAsExpression(right);\n\n    if (GLSLX.in_NodeKind.isBinaryAssign(node.kind)) {\n      this._checkStorage(left);\n    }\n\n    var leftType = left.resolvedType;\n    var rightType = right.resolvedType;\n    var isSame = leftType == rightType;\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.ADD:\n      case GLSLX.NodeKind.SUBTRACT:\n      case GLSLX.NodeKind.MULTIPLY:\n      case GLSLX.NodeKind.DIVIDE: {\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : leftType == GLSLX.Type.FLOAT && rightType.hasFloatComponents() ? rightType : leftType == GLSLX.Type.INT && rightType.hasIntComponents() ? rightType : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2) ? GLSLX.Type.VEC2 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3) ? GLSLX.Type.VEC3 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) ? GLSLX.Type.VEC4 : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.EQUAL:\n      case GLSLX.NodeKind.NOT_EQUAL: {\n        node.resolvedType = isSame && leftType.canUseEqualityOperators() ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.LOGICAL_AND:\n      case GLSLX.NodeKind.LOGICAL_OR:\n      case GLSLX.NodeKind.LOGICAL_XOR: {\n        node.resolvedType = isSame && leftType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.LESS_THAN:\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL:\n      case GLSLX.NodeKind.GREATER_THAN:\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\n        node.resolvedType = isSame && (leftType == GLSLX.Type.FLOAT || leftType == GLSLX.Type.INT) ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.ASSIGN: {\n        node.resolvedType = leftType;\n\n        if (leftType.containsArray) {\n          this._log.semanticErrorArrayAssignment(node.internalRange, leftType);\n        }\n\n        this.checkConversion(right, leftType);\n        return;\n      }\n\n      case GLSLX.NodeKind.ASSIGN_ADD:\n      case GLSLX.NodeKind.ASSIGN_SUBTRACT:\n      case GLSLX.NodeKind.ASSIGN_MULTIPLY:\n      case GLSLX.NodeKind.ASSIGN_DIVIDE: {\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : node.kind == GLSLX.NodeKind.ASSIGN_MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) ? leftType : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.INDEX: {\n        if (rightType == GLSLX.Type.INT) {\n          var indexType = leftType.indexType();\n\n          if (indexType != null) {\n            node.resolvedType = indexType;\n          }\n\n          // Run bounds checking on the constant-folded value\n          var folded = GLSLX.Folder.fold(right);\n\n          if (folded != null && folded.kind == GLSLX.NodeKind.INT) {\n            var value = folded.asInt();\n            var count = leftType.indexCount();\n\n            // Negative indices are always invalid even if the array size is unknown\n            if (value < 0 || count != 0 && value >= count) {\n              this._log.semanticErrorOutOfBoundsIndex(right.range, value, leftType);\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // If we get here, show an error about an invalid operator\n    if (node.resolvedType == GLSLX.Type.ERROR && leftType != GLSLX.Type.ERROR && rightType != GLSLX.Type.ERROR) {\n      if (node.kind == GLSLX.NodeKind.INDEX) {\n        this._log.semanticErrorBadIndex(node.internalRange, leftType, rightType);\n      }\n\n      else {\n        this._log.semanticErrorBadBinaryOperator(node.internalRange, node.internalRange.toString(), leftType, rightType);\n      }\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveCall = function(node) {\n    var callTarget = node.callTarget();\n    this.resolveNode(callTarget);\n    var type = callTarget.resolvedType;\n    var symbol = type.symbol;\n    var $arguments = [];\n    var hasError = false;\n\n    for (var child = callTarget.nextSibling(); child != null; child = child.nextSibling()) {\n      this._resolveAsExpression(child);\n      $arguments.push(child);\n\n      if (child.resolvedType == GLSLX.Type.ERROR) {\n        hasError = true;\n      }\n    }\n\n    if (hasError) {\n      return;\n    }\n\n    if (symbol != null) {\n      if (symbol.isFunction()) {\n        this._resolveFunctionOverloads(symbol.asFunction(), node, $arguments);\n        return;\n      }\n\n      if (symbol.isStruct()) {\n        this._resolveConstructor(type, node, $arguments);\n        return;\n      }\n    }\n\n    if (type != GLSLX.Type.ERROR) {\n      this._log.semanticErrorBadCall(callTarget.range, type);\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveDot = function(node) {\n    var dotTarget = node.dotTarget();\n    var name = node.asString();\n    var range = node.internalRange;\n    this._resolveAsExpression(dotTarget);\n    var type = dotTarget.resolvedType;\n    var isAssignTarget = node.isAssignTarget();\n\n    switch (type) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.VEC4: {\n        node.resolvedType = this._validateSwizzle(range, type, name, isAssignTarget);\n        break;\n      }\n\n      default: {\n        if (type.symbol != null && type.symbol.isStruct()) {\n          for (var i = 0, list = type.symbol.asStruct().variables, count = list.length; i < count; i = i + 1 | 0) {\n            var variable = in_List.get(list, i);\n\n            if (variable.name == name) {\n              node.symbol = variable;\n              this.resolveNode(variable.type);\n              node.resolvedType = variable.type.resolvedType;\n              break;\n            }\n          }\n        }\n\n        if (node.symbol == null) {\n          this._log.semanticErrorBadMember(range, type, name);\n        }\n        break;\n      }\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveFunctionOverloads = function(overloaded, node, $arguments) {\n    var overloads = [];\n\n    // Collect all relevant overloads but ignore forward-declared functions that also have an implementation\n    for (var overload = overloaded; overload != null; overload = overload.previousOverload) {\n      if (!(overloads.indexOf(overload.sibling) != -1)) {\n        overloads.push(overload);\n      }\n    }\n\n    // Narrow down by argument count\n    if (overloads.length != 1) {\n      overloads = overloads.slice();\n      in_List.removeIf(overloads, function(overload) {\n        return overload.$arguments.length != $arguments.length;\n      });\n\n      // Narrow down by argument types\n      if (overloads.length != 1) {\n        var overloadsBeforeTypeFilter = overloads.slice();\n        in_List.removeIf(overloads, function(overload) {\n          for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n            if (in_List.get(overload.$arguments, i).type.resolvedType != in_List.get($arguments, i).resolvedType) {\n              return true;\n            }\n          }\n\n          return false;\n        });\n\n        // Narrow down by argument types with \"conversions\" to get better error messages\n        if (overloads.length != 1) {\n          overloads = overloadsBeforeTypeFilter;\n          in_List.removeIf(overloads, function(overload) {\n            for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n              var from = in_List.get(overload.$arguments, i).type.resolvedType;\n              var to = in_List.get($arguments, i).resolvedType;\n              var fromSize = from.componentCount();\n              var toSize = to.componentCount();\n\n              if (from != to && (fromSize == 0 || toSize == 0 || fromSize != toSize)) {\n                return true;\n              }\n            }\n\n            return false;\n          });\n        }\n      }\n    }\n\n    // Match failure\n    if (overloads.length != 1) {\n      this._log.semanticErrorBadOverloadMatch(node.callTarget().range, overloaded.name);\n      return;\n    }\n\n    // Match success\n    var overload1 = in_List.first(overloads);\n\n    if (overload1.$arguments.length != $arguments.length) {\n      this._log.semanticErrorArgumentCountFunction(node.internalRange, overload1.$arguments.length, $arguments.length, overload1.name, overload1.range);\n    }\n\n    else {\n      for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n        this.checkConversion(in_List.get($arguments, i), in_List.get(overload1.$arguments, i).type.resolvedType);\n      }\n    }\n\n    node.callTarget().symbol = overload1;\n    node.resolvedType = overload1.returnType.resolvedType;\n  };\n\n  GLSLX.Resolver.prototype._resolveConstructor = function(type, node, $arguments) {\n    node.resolvedType = type;\n\n    if (type == GLSLX.Type.ERROR) {\n      return;\n    }\n\n    if (type.componentType() != null) {\n      var count = type.componentCount();\n      var hasMatrixArgument = false;\n\n      // Visit each argument and make sure it's useful toward construction\n      var providedCount = 0;\n\n      for (var i1 = 0, list = $arguments, count1 = list.length; i1 < count1; i1 = i1 + 1 | 0) {\n        var argument = in_List.get(list, i1);\n        var argumentType = argument.resolvedType;\n        var deltaCount = argumentType.componentCount();\n\n        // Each type in a component-based types must be able to itself be unpacked into components\n        if (argumentType.componentType() == null) {\n          if (argumentType != GLSLX.Type.ERROR) {\n            this._log.semanticErrorBadConstructorValue(argument.range, argumentType, type);\n          }\n\n          return;\n        }\n\n        // Passing extra values to a constructor is allowed sometimes\n        //\n        // Allowed:\n        //\n        //   vec3(vec4(1.0));\n        //   vec3(1.0, vec4(1.0));\n        //\n        // Not allowed:\n        //\n        //   vec3(vec4(1.0), 1.0);\n        //   vec3(vec3(1.0), vec3(1.0));\n        //\n        if (providedCount >= count) {\n          this._log.semanticErrorExtraConstructorValue(argument.range, type, count, providedCount + deltaCount | 0);\n        }\n\n        if (argumentType.isMatrix()) {\n          hasMatrixArgument = true;\n        }\n\n        providedCount = providedCount + deltaCount | 0;\n      }\n\n      // If a matrix argument is given to a matrix constructor, it is an error\n      // to have any other arguments\n      var isMatrixMatrixConstructor = type.isMatrix() && hasMatrixArgument;\n\n      if (isMatrixMatrixConstructor && $arguments.length != 1) {\n        this._log.semanticErrorBadMatrixConstructor(node.internalRange);\n      }\n\n      // Validate the count (constructing a matrix using a matrix should always work)\n      else if (providedCount < count && providedCount != 1 && !isMatrixMatrixConstructor) {\n        this._log.semanticErrorBadConstructorCount(node.internalRange, type, providedCount);\n      }\n\n      return;\n    }\n\n    var symbol = type.symbol.asStruct();\n    var variables = symbol.variables;\n    var variableCount = variables.length;\n    var argumentCount = $arguments.length;\n\n    // Validate argument count\n    if (variableCount != argumentCount) {\n      this._log.semanticErrorArgumentCountConstructor(node.internalRange, variableCount, argumentCount, symbol.name, symbol.range);\n      return;\n    }\n\n    // Validate argument types\n    for (var i = 0, count2 = variableCount; i < count2; i = i + 1 | 0) {\n      this.checkConversion(in_List.get($arguments, i), in_List.get(variables, i).type.resolvedType);\n    }\n  };\n\n  GLSLX.Resolver.prototype._validateSwizzle = function(range, type, name, isAssignTarget) {\n    var count = name.length;\n\n    if (count > 4) {\n      this._log.semanticErrorBadSwizzle(range, type, name);\n      return GLSLX.Type.ERROR;\n    }\n\n    var componentCount = type.componentCount();\n\n    for (var i1 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i1 < count2; i1 = i1 + 1 | 0) {\n      var set = in_List.get(list, i1);\n\n      if (set.indexOf(in_string.get(name, 0)) != -1) {\n        for (var i = 1, count1 = count; i < count1; i = i + 1 | 0) {\n          if (!(set.indexOf(in_string.get(name, i)) != -1)) {\n            this._log.semanticErrorBadSwizzle(range, type, name);\n            return GLSLX.Type.ERROR;\n          }\n\n          if (isAssignTarget && in_string.slice2(name, 0, i).indexOf(in_string.get(name, i)) != -1) {\n            this._log.semanticErrorBadSwizzleAssignment(range.slice(i, i + 1 | 0), in_string.get(name, i));\n            return GLSLX.Type.ERROR;\n          }\n        }\n\n        return GLSLX.Swizzle.type(type.componentType(), count);\n      }\n    }\n\n    this._log.semanticErrorBadSwizzle(range, type, name);\n    return GLSLX.Type.ERROR;\n  };\n\n  GLSLX.Resolver.prototype._resolveAsExpression = function(node) {\n    this.resolveNode(node);\n\n    if (node.kind == GLSLX.NodeKind.TYPE && node.resolvedType != GLSLX.Type.ERROR) {\n      this._log.semanticErrorUnexpectedType(node.range, node.resolvedType);\n      node.resolvedType = GLSLX.Type.ERROR;\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveChildren = function(node) {\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n      this.resolveNode(child);\n    }\n  };\n\n  GLSLX.Resolver.prototype._checkStorage = function(node) {\n    var n = node;\n    assert(GLSLX.in_NodeKind.isExpression(node.kind));\n\n    label: while (true) {\n      if (n.resolvedType == GLSLX.Type.ERROR) {\n        break;\n      }\n\n      switch (n.kind) {\n        case GLSLX.NodeKind.NAME: {\n          if (n.symbol.isConst()) {\n            this._log.semanticErrorBadStorage(node.range);\n          }\n\n          break label;\n        }\n\n        case GLSLX.NodeKind.DOT: {\n          n = n.dotTarget();\n          break;\n        }\n\n        case GLSLX.NodeKind.INDEX: {\n          n = n.binaryLeft();\n          break;\n        }\n\n        default: {\n          this._log.semanticErrorBadStorage(node.range);\n          break label;\n        }\n      }\n    }\n  };\n\n  GLSLX.Resolver.prototype.checkConversion = function(node, type) {\n    if (node.resolvedType != type && node.resolvedType != GLSLX.Type.ERROR && type != GLSLX.Type.ERROR) {\n      this._log.semanticErrorBadConversion(node.range, node.resolvedType, type);\n      node.resolvedType = GLSLX.Type.ERROR;\n    }\n  };\n\n  GLSLX.ScopeKind = {\n    FUNCTION: 0,\n    GLOBAL: 1,\n    LOCAL: 2,\n    LOOP: 3,\n    STRUCT: 4\n  };\n\n  GLSLX.Scope = function(kind, parent) {\n    this.kind = kind;\n    this.parent = parent;\n    this.symbols = Object.create(null);\n  };\n\n  GLSLX.Scope.prototype.define = function(symbol) {\n    assert(!(symbol.name in this.symbols));\n    this.symbols[symbol.name] = symbol;\n  };\n\n  GLSLX.Scope.prototype.redefine = function(symbol) {\n    assert(symbol.name in this.symbols);\n    assert(in_StringMap.get1(this.symbols, symbol.name) != symbol);\n    this.symbols[symbol.name] = symbol;\n  };\n\n  GLSLX.Scope.prototype.find = function(name) {\n    var symbol = in_StringMap.get(this.symbols, name, null);\n\n    if (symbol != null) {\n      return symbol;\n    }\n\n    if (this.parent != null) {\n      return this.parent.find(name);\n    }\n\n    return null;\n  };\n\n  GLSLX.LineColumn = function(line, column) {\n    this.line = line;\n    this.column = column;\n  };\n\n  GLSLX.Source = function(name, contents) {\n    this.name = name;\n    this.contents = contents;\n    this.tokens = null;\n    this._lineOffsets = null;\n  };\n\n  GLSLX.Source.prototype.indexToLineColumn = function(index) {\n    this._computeLineOffsets();\n\n    // Binary search to find the line\n    var count = this._lineOffsets.length;\n    var line = 0;\n\n    while (count > 0) {\n      var step = count / 2 | 0;\n      var i = line + step | 0;\n\n      if (in_List.get(this._lineOffsets, i) <= index) {\n        line = i + 1 | 0;\n        count = (count - step | 0) - 1 | 0;\n      }\n\n      else {\n        count = step;\n      }\n    }\n\n    // Use the line to compute the column\n    var column = line > 0 ? index - in_List.get(this._lineOffsets, line - 1 | 0) | 0 : index;\n    return new GLSLX.LineColumn(line - 1 | 0, column);\n  };\n\n  GLSLX.Source.prototype._computeLineOffsets = function() {\n    if (this._lineOffsets == null) {\n      this._lineOffsets = [0];\n\n      for (var i = 0, count = this.contents.length; i < count; i = i + 1 | 0) {\n        if (in_string.get1(this.contents, i) == 10) {\n          this._lineOffsets.push(i + 1 | 0);\n        }\n      }\n    }\n  };\n\n  GLSLX.Swizzle = {};\n\n  GLSLX.Swizzle.strings = function(componentCount) {\n    switch (componentCount) {\n      case 2: {\n        return GLSLX.Swizzle._STRINGS_2;\n      }\n\n      case 3: {\n        return GLSLX.Swizzle._STRINGS_3;\n      }\n\n      case 4: {\n        return GLSLX.Swizzle._STRINGS_4;\n      }\n    }\n\n    assert(false);\n    return null;\n  };\n\n  GLSLX.Swizzle.type = function(comonentType, componentCount) {\n    switch (comonentType) {\n      case GLSLX.Type.BOOL: {\n        switch (componentCount) {\n          case 1: {\n            return GLSLX.Type.BOOL;\n          }\n\n          case 2: {\n            return GLSLX.Type.BVEC2;\n          }\n\n          case 3: {\n            return GLSLX.Type.BVEC3;\n          }\n\n          case 4: {\n            return GLSLX.Type.BVEC4;\n          }\n        }\n        break;\n      }\n\n      case GLSLX.Type.FLOAT: {\n        switch (componentCount) {\n          case 1: {\n            return GLSLX.Type.FLOAT;\n          }\n\n          case 2: {\n            return GLSLX.Type.VEC2;\n          }\n\n          case 3: {\n            return GLSLX.Type.VEC3;\n          }\n\n          case 4: {\n            return GLSLX.Type.VEC4;\n          }\n        }\n        break;\n      }\n\n      case GLSLX.Type.INT: {\n        switch (componentCount) {\n          case 1: {\n            return GLSLX.Type.INT;\n          }\n\n          case 2: {\n            return GLSLX.Type.IVEC2;\n          }\n\n          case 3: {\n            return GLSLX.Type.IVEC3;\n          }\n\n          case 4: {\n            return GLSLX.Type.IVEC4;\n          }\n        }\n        break;\n      }\n    }\n\n    assert(false);\n    return null;\n  };\n\n  GLSLX.SymbolFlags = {\n    // Keyword modifiers\n    ATTRIBUTE: 1,\n    CONST: 2,\n    HIGHP: 4,\n    IN: 8,\n    INOUT: 16,\n    LOWP: 32,\n    MEDIUMP: 64,\n    OUT: 128,\n    UNIFORM: 256,\n    VARYING: 512,\n\n    // Internal compiler flags\n    EXPORTED: 1024,\n    IMPORTED: 2048\n  };\n\n  GLSLX.Symbol = function(id, range, name, scope) {\n    this.id = id;\n    this.range = range;\n    this.name = name;\n    this.scope = scope;\n    this.flags = 0;\n    this.constantValue = null;\n    this.requiredExtension = null;\n    this._resolvedType = null;\n  };\n\n  GLSLX.Symbol.prototype.isConst = function() {\n    return (GLSLX.SymbolFlags.CONST & this.flags) != 0;\n  };\n\n  GLSLX.Symbol.prototype.isStruct = function() {\n    return this instanceof GLSLX.StructSymbol;\n  };\n\n  GLSLX.Symbol.prototype.isFunction = function() {\n    return this instanceof GLSLX.FunctionSymbol;\n  };\n\n  GLSLX.Symbol.prototype.isVariable = function() {\n    return this instanceof GLSLX.VariableSymbol;\n  };\n\n  GLSLX.Symbol.prototype.asStruct = function() {\n    assert(this.isStruct());\n    return this;\n  };\n\n  GLSLX.Symbol.prototype.asFunction = function() {\n    assert(this.isFunction());\n    return this;\n  };\n\n  GLSLX.Symbol.prototype.asVariable = function() {\n    assert(this.isVariable());\n    return this;\n  };\n\n  GLSLX.Symbol.prototype.resolvedType = function() {\n    if (this._resolvedType == null) {\n      this._resolvedType = new GLSLX.Type(this, null, 0);\n    }\n\n    return this._resolvedType;\n  };\n\n  GLSLX.StructSymbol = function(id, range, name, scope) {\n    GLSLX.Symbol.call(this, id, range, name, scope);\n    this.variables = [];\n  };\n\n  __extends(GLSLX.StructSymbol, GLSLX.Symbol);\n\n  GLSLX.FunctionSymbol = function(id, range, name, scope) {\n    GLSLX.Symbol.call(this, id, range, name, scope);\n    this.$arguments = [];\n    this.returnType = null;\n    this.block = null;\n    this.previousOverload = null;\n    this.sibling = null;\n  };\n\n  __extends(GLSLX.FunctionSymbol, GLSLX.Symbol);\n\n  GLSLX.FunctionSymbol.prototype.hasSameArgumentTypesAs = function($function) {\n    if (this.$arguments.length != $function.$arguments.length) {\n      return false;\n    }\n\n    for (var i = 0, count = this.$arguments.length; i < count; i = i + 1 | 0) {\n      if (in_List.get(this.$arguments, i).type.resolvedType != in_List.get($function.$arguments, i).type.resolvedType) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  GLSLX.VariableKind = {\n    ARGUMENT: 0,\n    GLOBAL: 1,\n    LOCAL: 2,\n    STRUCT: 3\n  };\n\n  GLSLX.VariableSymbol = function(id, range, name, scope, kind) {\n    GLSLX.Symbol.call(this, id, range, name, scope);\n    this.kind = kind;\n    this.type = null;\n    this.value = null;\n    this.arrayCount = null;\n  };\n\n  __extends(GLSLX.VariableSymbol, GLSLX.Symbol);\n\n  GLSLX.TokenKind = {\n    // Standard keywords\n    ATTRIBUTE: 0,\n    BOOL: 1,\n    BREAK: 2,\n    BVEC2: 3,\n    BVEC3: 4,\n    BVEC4: 5,\n    CONST: 6,\n    CONTINUE: 7,\n    DISCARD: 8,\n    DO: 9,\n    ELSE: 10,\n    FALSE: 11,\n    FLOAT: 12,\n    FOR: 13,\n    HIGHP: 14,\n    IF: 15,\n    IN: 16,\n    INOUT: 17,\n    INT: 18,\n    INVARIANT: 19,\n    IVEC2: 20,\n    IVEC3: 21,\n    IVEC4: 22,\n    LOWP: 23,\n    MAT2: 24,\n    MAT3: 25,\n    MAT4: 26,\n    MEDIUMP: 27,\n    OUT: 28,\n    PRECISION: 29,\n    RETURN: 30,\n    SAMPLER2D: 31,\n    SAMPLERCUBE: 32,\n    STRUCT: 33,\n    TRUE: 34,\n    UNIFORM: 35,\n    VARYING: 36,\n    VEC2: 37,\n    VEC3: 38,\n    VEC4: 39,\n    VOID: 40,\n    WHILE: 41,\n\n    // Non-standard keywords\n    EXPORT: 42,\n    IMPORT: 43,\n\n    // Unary\n    COMPLEMENT: 44,\n    DECREMENT: 45,\n    INCREMENT: 46,\n    NOT: 47,\n\n    // Binary\n    BITWISE_AND: 48,\n    BITWISE_OR: 49,\n    BITWISE_XOR: 50,\n    DIVIDE: 51,\n    EQUAL: 52,\n    GREATER_THAN: 53,\n    GREATER_THAN_OR_EQUAL: 54,\n    LESS_THAN: 55,\n    LESS_THAN_OR_EQUAL: 56,\n    LOGICAL_AND: 57,\n    LOGICAL_OR: 58,\n    LOGICAL_XOR: 59,\n    MINUS: 60,\n    MULTIPLY: 61,\n    NOT_EQUAL: 62,\n    PLUS: 63,\n    REMAINDER: 64,\n    SHIFT_LEFT: 65,\n    SHIFT_RIGHT: 66,\n\n    // Binary assignment\n    ASSIGN: 67,\n    ASSIGN_ADD: 68,\n    ASSIGN_BITWISE_AND: 69,\n    ASSIGN_BITWISE_OR: 70,\n    ASSIGN_BITWISE_XOR: 71,\n    ASSIGN_DIVIDE: 72,\n    ASSIGN_MULTIPLY: 73,\n    ASSIGN_REMAINDER: 74,\n    ASSIGN_SHIFT_LEFT: 75,\n    ASSIGN_SHIFT_RIGHT: 76,\n    ASSIGN_SUBTRACT: 77,\n\n    // Other operators\n    COLON: 78,\n    COMMA: 79,\n    DOT: 80,\n    LEFT_BRACE: 81,\n    LEFT_BRACKET: 82,\n    LEFT_PARENTHESIS: 83,\n    QUESTION: 84,\n    RIGHT_BRACE: 85,\n    RIGHT_BRACKET: 86,\n    RIGHT_PARENTHESIS: 87,\n    SEMICOLON: 88,\n\n    // Pragmas\n    EXTENSION: 89,\n    VERSION: 90,\n    INCLUDE: 91,\n\n    // Literals\n    FLOAT_LITERAL: 92,\n    IDENTIFIER: 93,\n    INT_LITERAL: 94,\n    STRING_LITERAL: 95,\n\n    // This is always at the end of the token stream\n    END_OF_FILE: 96\n  };\n\n  GLSLX.Token = function(range, kind) {\n    this.range = range;\n    this.kind = kind;\n  };\n\n  GLSLX.Tokenizer = {};\n\n  GLSLX.Tokenizer.tokenize = function(log, source) {\n    var parts = source.contents.split(GLSLX.Tokenizer._tokenRegex);\n    var tokens = [];\n    var start = 0;\n\n    for (var i = 0, count1 = parts.length; i < count1; i = i + 1 | 0) {\n      var part = in_List.get(parts, i);\n      var count = part.length;\n      var end = start + count | 0;\n      var range = new GLSLX.Range(source, start, end);\n\n      if (i % 2 != 0) {\n        var c = in_string.get1(part, 0);\n\n        // Identifier\n        if (c >= 65 && c <= 90 || c >= 97 && c <= 122 || c == 95) {\n          var keyword = in_StringMap.get(GLSLX.Tokenizer.keywords, part, GLSLX.TokenKind.END_OF_FILE);\n\n          if (keyword != GLSLX.TokenKind.END_OF_FILE) {\n            tokens.push(new GLSLX.Token(range, keyword));\n          }\n\n          else if (part in GLSLX.Tokenizer.reservedWords) {\n            log.syntaxErrorReservedWord(range);\n          }\n\n          else {\n            tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.IDENTIFIER));\n          }\n        }\n\n        // Number\n        else if (c >= 48 && c <= 57 || c == 46 && count > 1) {\n          tokens.push(new GLSLX.Token(range, GLSLX.Tokenizer._intRegex.test(part) ? GLSLX.TokenKind.INT_LITERAL : GLSLX.TokenKind.FLOAT_LITERAL));\n        }\n\n        // Pragma\n        else if (c == 35) {\n          tokens.push(new GLSLX.Token(range, in_string.get1(part, 1) == 118 ? GLSLX.TokenKind.VERSION : in_string.get1(part, 1) == 101 ? GLSLX.TokenKind.EXTENSION : GLSLX.TokenKind.INCLUDE));\n        }\n\n        // String literal\n        else if (c == 34) {\n          tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.STRING_LITERAL));\n        }\n\n        // Operator\n        else {\n          var kind = in_StringMap.get(GLSLX.Tokenizer.operators, part, GLSLX.TokenKind.END_OF_FILE);\n\n          if (kind != GLSLX.TokenKind.END_OF_FILE) {\n            tokens.push(new GLSLX.Token(range, kind));\n          }\n        }\n      }\n\n      else if (part != '') {\n        log.syntaxErrorExtraData(range, part);\n        break;\n      }\n\n      start = end;\n    }\n\n    tokens.push(new GLSLX.Token(new GLSLX.Range(source, start, start), GLSLX.TokenKind.END_OF_FILE));\n    return tokens;\n  };\n\n  GLSLX.Type = function(symbol, isArrayOf, arrayCount) {\n    this.symbol = symbol;\n    this.isArrayOf = isArrayOf;\n    this.arrayCount = arrayCount;\n    this.containsArray = false;\n    this.containsSampler = false;\n    this._arrayTypes = null;\n  };\n\n  // A count of \"0\" means an array with an unknown size\n  GLSLX.Type.prototype.arrayType = function(count) {\n    assert(count >= 0);\n\n    if (this._arrayTypes == null) {\n      this._arrayTypes = {};\n    }\n\n    var arrayType = in_IntMap.get(this._arrayTypes, count, null);\n\n    if (arrayType == null) {\n      this._arrayTypes[count] = arrayType = new GLSLX.Type(null, this, count);\n      arrayType.containsArray = true;\n      arrayType.containsSampler = this.containsSampler;\n    }\n\n    return arrayType;\n  };\n\n  GLSLX.Type.prototype.toString = function() {\n    if (this.isArrayOf != null) {\n      return this.arrayCount != 0 ? this.isArrayOf.toString() + '[' + this.arrayCount.toString() + ']' : this.isArrayOf.toString() + '[]';\n    }\n\n    return this.symbol.name;\n  };\n\n  // For index expressions where \"0 <= index < indexCount\" (so indexCount == 0 means this type is un-indexable)\n  GLSLX.Type.prototype.indexCount = function() {\n    switch (this) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.MAT2: {\n        return 2;\n      }\n\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.MAT3: {\n        return 3;\n      }\n\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.VEC4:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.MAT4: {\n        return 4;\n      }\n\n      default: {\n        return this.arrayCount;\n      }\n    }\n  };\n\n  // For index expressions\n  GLSLX.Type.prototype.indexType = function() {\n    switch (this) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.BVEC4: {\n        return GLSLX.Type.BOOL;\n      }\n\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4: {\n        return GLSLX.Type.FLOAT;\n      }\n\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4: {\n        return GLSLX.Type.INT;\n      }\n\n      case GLSLX.Type.MAT2: {\n        return GLSLX.Type.VEC2;\n      }\n\n      case GLSLX.Type.MAT3: {\n        return GLSLX.Type.VEC3;\n      }\n\n      case GLSLX.Type.MAT4: {\n        return GLSLX.Type.VEC4;\n      }\n\n      default: {\n        return this.isArrayOf;\n      }\n    }\n  };\n\n  // For constructor expressions, returns the number of required elements\n  GLSLX.Type.prototype.componentCount = function() {\n    switch (this) {\n      case GLSLX.Type.BOOL:\n      case GLSLX.Type.FLOAT:\n      case GLSLX.Type.INT: {\n        return 1;\n      }\n\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.IVEC2: {\n        return 2;\n      }\n\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.IVEC3: {\n        return 3;\n      }\n\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.VEC4:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.MAT2: {\n        return 4;\n      }\n\n      case GLSLX.Type.MAT3: {\n        return 9;\n      }\n\n      case GLSLX.Type.MAT4: {\n        return 16;\n      }\n\n      default: {\n        return 0;\n      }\n    }\n  };\n\n  // For constructor expressions, returns the base element type corresponding to componentCount\n  GLSLX.Type.prototype.componentType = function() {\n    switch (this) {\n      case GLSLX.Type.BOOL:\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.BVEC4: {\n        return GLSLX.Type.BOOL;\n      }\n\n      case GLSLX.Type.FLOAT:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4:\n      case GLSLX.Type.MAT2:\n      case GLSLX.Type.MAT3:\n      case GLSLX.Type.MAT4: {\n        return GLSLX.Type.FLOAT;\n      }\n\n      case GLSLX.Type.INT:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4: {\n        return GLSLX.Type.INT;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  };\n\n  // Vector types are the only ones with swizzles\n  GLSLX.Type.prototype.isVector = function() {\n    switch (this) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.isMatrix = function() {\n    switch (this) {\n      case GLSLX.Type.MAT2:\n      case GLSLX.Type.MAT3:\n      case GLSLX.Type.MAT4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.hasIntComponents = function() {\n    switch (this) {\n      case GLSLX.Type.INT:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.hasFloatComponents = function() {\n    switch (this) {\n      case GLSLX.Type.FLOAT:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4: {\n        return true;\n      }\n\n      case GLSLX.Type.MAT2:\n      case GLSLX.Type.MAT3:\n      case GLSLX.Type.MAT4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.isIntOrFloat = function() {\n    return this.hasIntComponents() || this.hasFloatComponents();\n  };\n\n  GLSLX.Type.prototype.canUseEqualityOperators = function() {\n    return !this.containsSampler && !this.containsArray;\n  };\n\n  GLSLX.Type.prototype._setContainsSampler = function() {\n    this.containsSampler = true;\n    return this;\n  };\n\n  GLSLX.Exports = {};\n\n  GLSLX.Exports.sourcesFromInput = function(input) {\n    if (__isString(input)) {\n      return [new GLSLX.Source('<stdin>', input)];\n    }\n\n    if (input instanceof Array) {\n      var sources = [];\n\n      for (var i = 0, count = input.length; i < count; i = i + 1 | 0) {\n        sources.push(new GLSLX.Source(input[i].name, input[i].contents));\n      }\n\n      return sources;\n    }\n\n    return [new GLSLX.Source(input.name, input.contents)];\n  };\n\n  GLSLX.Exports.main = function() {\n    var $this = (function() {\n      return this;\n    })();\n    var root = typeof exports !== 'undefined' ? exports : $this.GLSLX = {};\n\n    // API exports\n    root.check = GLSLX.Exports.check;\n  };\n\n  GLSLX.Exports.check = function(input, args) {\n    args = args || {};\n    var sources = GLSLX.Exports.sourcesFromInput(input);\n    var log = new GLSLX.Log();\n    var options = new GLSLX.CompilerOptions();\n\n    if (args.disableRewriting) {\n      options.compactSyntaxTree = false;\n    }\n\n    if (args.prettyPrint) {\n      options.removeWhitespace = false;\n    }\n\n    if (args.keepSymbols) {\n      options.trimSymbols = false;\n    }\n\n    if (args.globals) {\n      options.globals = args.globals;\n    }\n\n    var result = GLSLX.Compiler.typeCheck(log, sources, options);\n    return {'log': log, 'result': result};\n  };\n\n  GLSLX.in_NodeKind = {};\n\n  GLSLX.in_NodeKind.isStatement = function(self) {\n    return self >= GLSLX.NodeKind.BLOCK && self <= GLSLX.NodeKind.WHILE;\n  };\n\n  GLSLX.in_NodeKind.isExpression = function(self) {\n    return self >= GLSLX.NodeKind.CALL && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\n  };\n\n  GLSLX.in_NodeKind.isUnary = function(self) {\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isUnaryPrefix = function(self) {\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.PREFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isUnaryPostfix = function(self) {\n    return self >= GLSLX.NodeKind.POSTFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isUnaryAssign = function(self) {\n    return self >= GLSLX.NodeKind.PREFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isBinary = function(self) {\n    return self >= GLSLX.NodeKind.ADD && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\n  };\n\n  GLSLX.in_NodeKind.isBinaryAssign = function(self) {\n    return self >= GLSLX.NodeKind.ASSIGN && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\n  };\n\n  GLSLX.in_NodeKind.isLoop = function(self) {\n    return self == GLSLX.NodeKind.DO_WHILE || self == GLSLX.NodeKind.FOR || self == GLSLX.NodeKind.WHILE;\n  };\n\n  GLSLX.in_TokenKind = {};\n  var in_string = {};\n\n  in_string.slice2 = function(self, start, end) {\n    assert(0 <= start && start <= end && end <= self.length);\n    return self.slice(start, end);\n  };\n\n  in_string.get1 = function(self, index) {\n    assert(0 <= index && index < self.length);\n    return self.charCodeAt(index);\n  };\n\n  in_string.get = function(self, index) {\n    assert(0 <= index && index < self.length);\n    return self[index];\n  };\n\n  var in_List = {};\n\n  in_List.setLast = function(self, x) {\n    return in_List.set(self, self.length - 1 | 0, x);\n  };\n\n  in_List.get = function(self, index) {\n    assert(0 <= index && index < self.length);\n    return self[index];\n  };\n\n  in_List.set = function(self, index, value) {\n    assert(0 <= index && index < self.length);\n    return self[index] = value;\n  };\n\n  in_List.first = function(self) {\n    assert(!(self.length == 0));\n    return in_List.get(self, 0);\n  };\n\n  in_List.last = function(self) {\n    assert(!(self.length == 0));\n    return in_List.get(self, self.length - 1 | 0);\n  };\n\n  in_List.removeLast = function(self) {\n    assert(!(self.length == 0));\n    self.pop();\n  };\n\n  in_List.takeLast = function(self) {\n    assert(!(self.length == 0));\n    return self.pop();\n  };\n\n  in_List.removeIf = function(self, callback) {\n    var index = 0;\n\n    // Remove elements in place\n    for (var i = 0, count1 = self.length; i < count1; i = i + 1 | 0) {\n      if (!callback(in_List.get(self, i))) {\n        if (index < i) {\n          in_List.set(self, index, in_List.get(self, i));\n        }\n\n        index = index + 1 | 0;\n      }\n    }\n\n    // Shrink the array to the correct size\n    while (index < self.length) {\n      in_List.removeLast(self);\n    }\n  };\n\n  var in_StringMap = {};\n\n  in_StringMap.get1 = function(self, key) {\n    assert(key in self);\n    return self[key];\n  };\n\n  in_StringMap.insert = function(self, key, value) {\n    self[key] = value;\n    return self;\n  };\n\n  in_StringMap.get = function(self, key, defaultValue) {\n    var value = self[key];\n\n    // Compare against undefined so the key is only hashed once for speed\n    return value !== void 0 ? value : defaultValue;\n  };\n\n  in_StringMap.values = function(self) {\n    var values = [];\n\n    for (var key in self) {\n      values.push(in_StringMap.get1(self, key));\n    }\n\n    return values;\n  };\n\n  var in_IntMap = {};\n\n  in_IntMap.get = function(self, key, defaultValue) {\n    var value = self[key];\n\n    // Compare against undefined so the key is only hashed once for speed\n    return value !== void 0 ? value : defaultValue;\n  };\n\n  var RELEASE = false;\n\n  // This is from https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n  GLSLX.API = '\\nimport {\\n  highp vec4 gl_Position; // should be written to\\n  mediump float gl_PointSize; // may be written to\\n\\n  const int gl_MaxVertexAttribs;\\n  const int gl_MaxVertexUniformVectors;\\n  const int gl_MaxVaryingVectors;\\n  const int gl_MaxVertexTextureImageUnits;\\n  const int gl_MaxCombinedTextureImageUnits;\\n  const int gl_MaxTextureImageUnits;\\n  const int gl_MaxFragmentUniformVectors;\\n  const int gl_MaxDrawBuffers;\\n\\n  const bool gl_FrontFacing;\\n  const mediump vec2 gl_PointCoord;\\n  const mediump vec4 gl_FragCoord;\\n  mediump vec4 gl_FragColor;\\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\\n\\n  struct gl_DepthRangeParameters {\\n    float near; // n\\n    float far; // f\\n    float diff; // f - n\\n  };\\n\\n  uniform gl_DepthRangeParameters gl_DepthRange;\\n\\n  // Angle and Trigonometry Functions\\n  float acos(float x);\\n  float asin(float x);\\n  float atan(float y, float x);\\n  float atan(float y_over_x);\\n  float cos(float angle);\\n  float degrees(float radians);\\n  float radians(float degrees);\\n  float sin(float angle);\\n  float tan(float angle);\\n  vec2 acos(vec2 x);\\n  vec2 asin(vec2 x);\\n  vec2 atan(vec2 y, vec2 x);\\n  vec2 atan(vec2 y_over_x);\\n  vec2 cos(vec2 angle);\\n  vec2 degrees(vec2 radians);\\n  vec2 radians(vec2 degrees);\\n  vec2 sin(vec2 angle);\\n  vec2 tan(vec2 angle);\\n  vec3 acos(vec3 x);\\n  vec3 asin(vec3 x);\\n  vec3 atan(vec3 y, vec3 x);\\n  vec3 atan(vec3 y_over_x);\\n  vec3 cos(vec3 angle);\\n  vec3 degrees(vec3 radians);\\n  vec3 radians(vec3 degrees);\\n  vec3 sin(vec3 angle);\\n  vec3 tan(vec3 angle);\\n  vec4 acos(vec4 x);\\n  vec4 asin(vec4 x);\\n  vec4 atan(vec4 y, vec4 x);\\n  vec4 atan(vec4 y_over_x);\\n  vec4 cos(vec4 angle);\\n  vec4 sin(vec4 angle);\\n  vec4 tan(vec4 angle);\\n\\n  // Exponential Functions\\n  float exp(float x);\\n  float exp2(float x);\\n  float inversesqrt(float x);\\n  float log(float x);\\n  float log2(float x);\\n  float pow(float x, float y);\\n  float sqrt(float x);\\n  vec2 exp(vec2 x);\\n  vec2 exp2(vec2 x);\\n  vec2 inversesqrt(vec2 x);\\n  vec2 log(vec2 x);\\n  vec2 log2(vec2 x);\\n  vec2 pow(vec2 x, vec2 y);\\n  vec2 sqrt(vec2 x);\\n  vec3 exp(vec3 x);\\n  vec3 exp2(vec3 x);\\n  vec3 inversesqrt(vec3 x);\\n  vec3 log(vec3 x);\\n  vec3 log2(vec3 x);\\n  vec3 pow(vec3 x, vec3 y);\\n  vec3 sqrt(vec3 x);\\n  vec4 exp(vec4 x);\\n  vec4 exp2(vec4 x);\\n  vec4 inversesqrt(vec4 x);\\n  vec4 log(vec4 x);\\n  vec4 log2(vec4 x);\\n  vec4 pow(vec4 x, vec4 y);\\n  vec4 sqrt(vec4 x);\\n\\n  // Common Functions\\n  float abs(float x);\\n  float ceil(float x);\\n  float clamp(float x, float minVal, float maxVal);\\n  float floor(float x);\\n  float fract(float x);\\n  float max(float x, float y);\\n  float min(float x, float y);\\n  float mix(float x, float y, float a);\\n  float mod(float x, float y);\\n  float sign(float x);\\n  float smoothstep(float edge0, float edge1, float x);\\n  float step(float edge, float x);\\n  vec2 abs(vec2 x);\\n  vec2 ceil(vec2 x);\\n  vec2 clamp(vec2 x, float minVal, float maxVal);\\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\\n  vec2 floor(vec2 x);\\n  vec2 fract(vec2 x);\\n  vec2 max(vec2 x, float y);\\n  vec2 max(vec2 x, vec2 y);\\n  vec2 min(vec2 x, float y);\\n  vec2 min(vec2 x, vec2 y);\\n  vec2 mix(vec2 x, vec2 y, float a);\\n  vec2 mix(vec2 x, vec2 y, vec2 a);\\n  vec2 mod(vec2 x, float y);\\n  vec2 mod(vec2 x, vec2 y);\\n  vec2 sign(vec2 x);\\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\\n  vec2 step(float edge, vec2 x);\\n  vec2 step(vec2 edge, vec2 x);\\n  vec3 abs(vec3 x);\\n  vec3 ceil(vec3 x);\\n  vec3 clamp(vec3 x, float minVal, float maxVal);\\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\\n  vec3 floor(vec3 x);\\n  vec3 fract(vec3 x);\\n  vec3 max(vec3 x, float y);\\n  vec3 max(vec3 x, vec3 y);\\n  vec3 min(vec3 x, float y);\\n  vec3 min(vec3 x, vec3 y);\\n  vec3 mix(vec3 x, vec3 y, float a);\\n  vec3 mix(vec3 x, vec3 y, vec3 a);\\n  vec3 mod(vec3 x, float y);\\n  vec3 mod(vec3 x, vec3 y);\\n  vec3 sign(vec3 x);\\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\\n  vec3 step(float edge, vec3 x);\\n  vec3 step(vec3 edge, vec3 x);\\n  vec4 abs(vec4 x);\\n  vec4 ceil(vec4 x);\\n  vec4 clamp(vec4 x, float minVal, float maxVal);\\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\\n  vec4 floor(vec4 x);\\n  vec4 fract(vec4 x);\\n  vec4 max(vec4 x, float y);\\n  vec4 max(vec4 x, vec4 y);\\n  vec4 min(vec4 x, float y);\\n  vec4 min(vec4 x, vec4 y);\\n  vec4 mix(vec4 x, vec4 y, float a);\\n  vec4 mix(vec4 x, vec4 y, vec4 a);\\n  vec4 mod(vec4 x, float y);\\n  vec4 mod(vec4 x, vec4 y);\\n  vec4 sign(vec4 x);\\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\\n  vec4 step(float edge, vec4 x);\\n  vec4 step(vec4 edge, vec4 x);\\n\\n  // Geometric Functions\\n  float distance(float p0, float p1);\\n  float distance(vec2 p0, vec2 p1);\\n  float distance(vec3 p0, vec3 p1);\\n  float distance(vec4 p0, vec4 p1);\\n  float dot(float x, float y);\\n  float dot(vec2 x, vec2 y);\\n  float dot(vec3 x, vec3 y);\\n  float dot(vec4 x, vec4 y);\\n  float faceforward(float N, float I, float Nref);\\n  float length(float x);\\n  float length(vec2 x);\\n  float length(vec3 x);\\n  float length(vec4 x);\\n  float normalize(float x);\\n  float reflect(float I, float N);\\n  float refract(float I, float N, float eta);\\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\\n  vec2 normalize(vec2 x);\\n  vec2 reflect(vec2 I, vec2 N);\\n  vec2 refract(vec2 I, vec2 N, float eta);\\n  vec3 cross(vec3 x, vec3 y);\\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\\n  vec3 normalize(vec3 x);\\n  vec3 reflect(vec3 I, vec3 N);\\n  vec3 refract(vec3 I, vec3 N, float eta);\\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\\n  vec4 normalize(vec4 x);\\n  vec4 reflect(vec4 I, vec4 N);\\n  vec4 refract(vec4 I, vec4 N, float eta);\\n\\n  // Matrix Functions\\n  mat2 matrixCompMult(mat2 x, mat2 y);\\n  mat3 matrixCompMult(mat3 x, mat3 y);\\n  mat4 matrixCompMult(mat4 x, mat4 y);\\n\\n  // Vector Relational Functions\\n  bool all(bvec2 x);\\n  bool all(bvec3 x);\\n  bool all(bvec4 x);\\n  bool any(bvec2 x);\\n  bool any(bvec3 x);\\n  bool any(bvec4 x);\\n  bvec2 equal(bvec2 x, bvec2 y);\\n  bvec2 equal(ivec2 x, ivec2 y);\\n  bvec2 equal(vec2 x, vec2 y);\\n  bvec2 greaterThan(ivec2 x, ivec2 y);\\n  bvec2 greaterThan(vec2 x, vec2 y);\\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\\n  bvec2 lessThan(ivec2 x, ivec2 y);\\n  bvec2 lessThan(vec2 x, vec2 y);\\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\\n  bvec2 lessThanEqual(vec2 x, vec2 y);\\n  bvec2 not(bvec2 x);\\n  bvec2 notEqual(bvec2 x, bvec2 y);\\n  bvec2 notEqual(ivec2 x, ivec2 y);\\n  bvec2 notEqual(vec2 x, vec2 y);\\n  bvec3 equal(bvec3 x, bvec3 y);\\n  bvec3 equal(ivec3 x, ivec3 y);\\n  bvec3 equal(vec3 x, vec3 y);\\n  bvec3 greaterThan(ivec3 x, ivec3 y);\\n  bvec3 greaterThan(vec3 x, vec3 y);\\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\\n  bvec3 lessThan(ivec3 x, ivec3 y);\\n  bvec3 lessThan(vec3 x, vec3 y);\\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\\n  bvec3 lessThanEqual(vec3 x, vec3 y);\\n  bvec3 not(bvec3 x);\\n  bvec3 notEqual(bvec3 x, bvec3 y);\\n  bvec3 notEqual(ivec3 x, ivec3 y);\\n  bvec3 notEqual(vec3 x, vec3 y);\\n  bvec4 equal(bvec4 x, bvec4 y);\\n  bvec4 equal(ivec4 x, ivec4 y);\\n  bvec4 equal(vec4 x, vec4 y);\\n  bvec4 greaterThan(ivec4 x, ivec4 y);\\n  bvec4 greaterThan(vec4 x, vec4 y);\\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\\n  bvec4 lessThan(ivec4 x, ivec4 y);\\n  bvec4 lessThan(vec4 x, vec4 y);\\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\\n  bvec4 lessThanEqual(vec4 x, vec4 y);\\n  bvec4 not(bvec4 x);\\n  bvec4 notEqual(bvec4 x, bvec4 y);\\n  bvec4 notEqual(ivec4 x, ivec4 y);\\n  bvec4 notEqual(vec4 x, vec4 y);\\n\\n  // Texture Lookup Functions\\n  vec4 texture2D(sampler2D sampler, vec2 coord);\\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\\n  vec4 textureCube(samplerCube sampler, vec3 coord);\\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\\n\\n  #extension GL_OES_standard_derivatives {\\n    float dFdx(float v);\\n    float dFdy(float v);\\n    float fwidth(float v);\\n    vec2 dFdx(vec2 v);\\n    vec2 dFdy(vec2 v);\\n    vec2 fwidth(vec2 v);\\n    vec3 dFdx(vec3 v);\\n    vec3 dFdy(vec3 v);\\n    vec3 fwidth(vec3 v);\\n    vec4 dFdx(vec4 v);\\n    vec4 dFdy(vec4 v);\\n    vec4 fwidth(vec4 v);\\n  }\\n\\n  #extension GL_EXT_frag_depth {\\n    float gl_FragDepthEXT;\\n  }\\n\\n  #extension GL_EXT_shader_texture_lod {\\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\\n  }\\n}\\n';\n  GLSLX.Node._nextID = 0;\n  GLSLX.Parser.pratt = null;\n  GLSLX.Parser._extensionBehaviors = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'disable', GLSLX.ExtensionBehavior.DISABLE), 'enable', GLSLX.ExtensionBehavior.ENABLE), 'require', GLSLX.ExtensionBehavior.REQUIRE), 'warn', GLSLX.ExtensionBehavior.WARN);\n\n  // From https://www.khronos.org/registry/webgl/extensions/\n  GLSLX.Parser._knownWebGLExtensions = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'GL_OES_standard_derivatives', 0), 'GL_EXT_frag_depth', 0), 'GL_EXT_draw_buffers', 0), 'GL_EXT_shader_texture_lod', 0);\n  GLSLX.Swizzle._STRINGS_2 = ['xy', 'st', 'rg'];\n  GLSLX.Swizzle._STRINGS_3 = ['xyz', 'stp', 'rgb'];\n  GLSLX.Swizzle._STRINGS_4 = ['xyzw', 'stpq', 'rgba'];\n\n  // The order matters here due to greedy matching\n  GLSLX.Tokenizer._tokenRegex = new RegExp('(' + '\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.|' + '[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[1-9][0-9]*\\\\b|' + '0[0-7]*\\\\b|' + '0[xX][0-9A-Fa-f]+\\\\b|' + '[ \\t\\r\\n]|' + '/\\\\*(?:.|\\r\\n|\\n)*?\\\\*/|' + '//.*|' + '&&|\\\\|\\\\||\\\\^\\\\^|\\\\+\\\\+|--|<<=?|>>=?|[()[\\\\]{}\\\\.,?:;]|[+\\\\-*/%=!<>&|^~]=?|' + '[A-Za-z_][A-Za-z0-9_]*\\\\b|' + '#(?:version|extension|include)\\\\b|' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')');\n  GLSLX.Tokenizer._intRegex = new RegExp('^(' + '[1-9][0-9]*|' + '0[0-7]*|' + '0[xX][0-9A-Fa-f]+' + ')$');\n  GLSLX.Tokenizer.keywords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'attribute', GLSLX.TokenKind.ATTRIBUTE), 'bool', GLSLX.TokenKind.BOOL), 'break', GLSLX.TokenKind.BREAK), 'bvec2', GLSLX.TokenKind.BVEC2), 'bvec3', GLSLX.TokenKind.BVEC3), 'bvec4', GLSLX.TokenKind.BVEC4), 'const', GLSLX.TokenKind.CONST), 'continue', GLSLX.TokenKind.CONTINUE), 'discard', GLSLX.TokenKind.DISCARD), 'do', GLSLX.TokenKind.DO), 'else', GLSLX.TokenKind.ELSE), 'false', GLSLX.TokenKind.FALSE), 'float', GLSLX.TokenKind.FLOAT), 'for', GLSLX.TokenKind.FOR), 'highp', GLSLX.TokenKind.HIGHP), 'if', GLSLX.TokenKind.IF), 'in', GLSLX.TokenKind.IN), 'inout', GLSLX.TokenKind.INOUT), 'int', GLSLX.TokenKind.INT), 'invariant', GLSLX.TokenKind.INVARIANT), 'ivec2', GLSLX.TokenKind.IVEC2), 'ivec3', GLSLX.TokenKind.IVEC3), 'ivec4', GLSLX.TokenKind.IVEC4), 'lowp', GLSLX.TokenKind.LOWP), 'mat2', GLSLX.TokenKind.MAT2), 'mat3', GLSLX.TokenKind.MAT3), 'mat4', GLSLX.TokenKind.MAT4), 'mediump', GLSLX.TokenKind.MEDIUMP), 'out', GLSLX.TokenKind.OUT), 'precision', GLSLX.TokenKind.PRECISION), 'return', GLSLX.TokenKind.RETURN), 'sampler2D', GLSLX.TokenKind.SAMPLER2D), 'samplerCube', GLSLX.TokenKind.SAMPLERCUBE), 'struct', GLSLX.TokenKind.STRUCT), 'true', GLSLX.TokenKind.TRUE), 'uniform', GLSLX.TokenKind.UNIFORM), 'varying', GLSLX.TokenKind.VARYING), 'vec2', GLSLX.TokenKind.VEC2), 'vec3', GLSLX.TokenKind.VEC3), 'vec4', GLSLX.TokenKind.VEC4), 'void', GLSLX.TokenKind.VOID), 'while', GLSLX.TokenKind.WHILE), 'export', GLSLX.TokenKind.EXPORT), 'import', GLSLX.TokenKind.IMPORT);\n  GLSLX.Tokenizer.operators = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), '~', GLSLX.TokenKind.COMPLEMENT), '--', GLSLX.TokenKind.DECREMENT), '++', GLSLX.TokenKind.INCREMENT), '!', GLSLX.TokenKind.NOT), '&', GLSLX.TokenKind.BITWISE_AND), '|', GLSLX.TokenKind.BITWISE_OR), '^', GLSLX.TokenKind.BITWISE_XOR), '/', GLSLX.TokenKind.DIVIDE), '==', GLSLX.TokenKind.EQUAL), '>', GLSLX.TokenKind.GREATER_THAN), '>=', GLSLX.TokenKind.GREATER_THAN_OR_EQUAL), '<', GLSLX.TokenKind.LESS_THAN), '<=', GLSLX.TokenKind.LESS_THAN_OR_EQUAL), '&&', GLSLX.TokenKind.LOGICAL_AND), '||', GLSLX.TokenKind.LOGICAL_OR), '^^', GLSLX.TokenKind.LOGICAL_XOR), '-', GLSLX.TokenKind.MINUS), '*', GLSLX.TokenKind.MULTIPLY), '!=', GLSLX.TokenKind.NOT_EQUAL), '+', GLSLX.TokenKind.PLUS), '%', GLSLX.TokenKind.REMAINDER), '<<', GLSLX.TokenKind.SHIFT_LEFT), '>>', GLSLX.TokenKind.SHIFT_RIGHT), '=', GLSLX.TokenKind.ASSIGN), '+=', GLSLX.TokenKind.ASSIGN_ADD), '&=', GLSLX.TokenKind.ASSIGN_BITWISE_AND), '|=', GLSLX.TokenKind.ASSIGN_BITWISE_OR), '^=', GLSLX.TokenKind.ASSIGN_BITWISE_XOR), '/=', GLSLX.TokenKind.ASSIGN_DIVIDE), '*=', GLSLX.TokenKind.ASSIGN_MULTIPLY), '%=', GLSLX.TokenKind.ASSIGN_REMAINDER), '<<=', GLSLX.TokenKind.ASSIGN_SHIFT_LEFT), '>>=', GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT), '-=', GLSLX.TokenKind.ASSIGN_SUBTRACT), ':', GLSLX.TokenKind.COLON), ',', GLSLX.TokenKind.COMMA), '.', GLSLX.TokenKind.DOT), '{', GLSLX.TokenKind.LEFT_BRACE), '[', GLSLX.TokenKind.LEFT_BRACKET), '(', GLSLX.TokenKind.LEFT_PARENTHESIS), '?', GLSLX.TokenKind.QUESTION), '}', GLSLX.TokenKind.RIGHT_BRACE), ']', GLSLX.TokenKind.RIGHT_BRACKET), ')', GLSLX.TokenKind.RIGHT_PARENTHESIS), ';', GLSLX.TokenKind.SEMICOLON);\n  GLSLX.Tokenizer.reservedWords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'asm', 0), 'cast', 0), 'class', 0), 'default', 0), 'double', 0), 'dvec2', 0), 'dvec3', 0), 'dvec4', 0), 'enum', 0), 'extern', 0), 'external', 0), 'fixed', 0), 'flat', 0), 'fvec2', 0), 'fvec3', 0), 'fvec4', 0), 'goto', 0), 'half', 0), 'hvec2', 0), 'hvec3', 0), 'hvec4', 0), 'inline', 0), 'input', 0), 'interface', 0), 'long', 0), 'namespace', 0), 'noinline', 0), 'output', 0), 'packed', 0), 'public', 0), 'sampler1D', 0), 'sampler1DShadow', 0), 'sampler2DRect', 0), 'sampler2DRectShadow', 0), 'sampler2DShadow', 0), 'sampler3D', 0), 'sampler3DRect', 0), 'short', 0), 'sizeof', 0), 'static', 0), 'superp', 0), 'switch', 0), 'template', 0), 'this', 0), 'typedef', 0), 'union', 0), 'unsigned', 0), 'using', 0), 'volatile', 0);\n  GLSLX.Type.BOOL = new GLSLX.StructSymbol(-1, null, 'bool', null).resolvedType();\n  GLSLX.Type.BVEC2 = new GLSLX.StructSymbol(-2, null, 'bvec2', null).resolvedType();\n  GLSLX.Type.BVEC3 = new GLSLX.StructSymbol(-3, null, 'bvec3', null).resolvedType();\n  GLSLX.Type.BVEC4 = new GLSLX.StructSymbol(-4, null, 'bvec4', null).resolvedType();\n  GLSLX.Type.ERROR = new GLSLX.StructSymbol(-5, null, '<error>', null).resolvedType();\n  GLSLX.Type.FLOAT = new GLSLX.StructSymbol(-6, null, 'float', null).resolvedType();\n  GLSLX.Type.INT = new GLSLX.StructSymbol(-7, null, 'int', null).resolvedType();\n  GLSLX.Type.IVEC2 = new GLSLX.StructSymbol(-8, null, 'ivec2', null).resolvedType();\n  GLSLX.Type.IVEC3 = new GLSLX.StructSymbol(-9, null, 'ivec3', null).resolvedType();\n  GLSLX.Type.IVEC4 = new GLSLX.StructSymbol(-10, null, 'ivec4', null).resolvedType();\n  GLSLX.Type.MAT2 = new GLSLX.StructSymbol(-11, null, 'mat2', null).resolvedType();\n  GLSLX.Type.MAT3 = new GLSLX.StructSymbol(-12, null, 'mat3', null).resolvedType();\n  GLSLX.Type.MAT4 = new GLSLX.StructSymbol(-13, null, 'mat4', null).resolvedType();\n  GLSLX.Type.SAMPLER2D = new GLSLX.StructSymbol(-14, null, 'sampler2D', null).resolvedType()._setContainsSampler();\n  GLSLX.Type.SAMPLERCUBE = new GLSLX.StructSymbol(-15, null, 'samplerCube', null).resolvedType()._setContainsSampler();\n  GLSLX.Type.VEC2 = new GLSLX.StructSymbol(-16, null, 'vec2', null).resolvedType();\n  GLSLX.Type.VEC3 = new GLSLX.StructSymbol(-17, null, 'vec3', null).resolvedType();\n  GLSLX.Type.VEC4 = new GLSLX.StructSymbol(-18, null, 'vec4', null).resolvedType();\n  GLSLX.Type.VOID = new GLSLX.StructSymbol(-19, null, 'void', null).resolvedType();\n  GLSLX.in_TokenKind._strings = ['ATTRIBUTE', 'BOOL', 'BREAK', 'BVEC2', 'BVEC3', 'BVEC4', 'CONST', 'CONTINUE', 'DISCARD', 'DO', 'ELSE', 'FALSE', 'FLOAT', 'FOR', 'HIGHP', 'IF', 'IN', 'INOUT', 'INT', 'INVARIANT', 'IVEC2', 'IVEC3', 'IVEC4', 'LOWP', 'MAT2', 'MAT3', 'MAT4', 'MEDIUMP', 'OUT', 'PRECISION', 'RETURN', 'SAMPLER2D', 'SAMPLERCUBE', 'STRUCT', 'TRUE', 'UNIFORM', 'VARYING', 'VEC2', 'VEC3', 'VEC4', 'VOID', 'WHILE', 'EXPORT', 'IMPORT', 'COMPLEMENT', 'DECREMENT', 'INCREMENT', 'NOT', 'BITWISE_AND', 'BITWISE_OR', 'BITWISE_XOR', 'DIVIDE', 'EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'LOGICAL_AND', 'LOGICAL_OR', 'LOGICAL_XOR', 'MINUS', 'MULTIPLY', 'NOT_EQUAL', 'PLUS', 'REMAINDER', 'SHIFT_LEFT', 'SHIFT_RIGHT', 'ASSIGN', 'ASSIGN_ADD', 'ASSIGN_BITWISE_AND', 'ASSIGN_BITWISE_OR', 'ASSIGN_BITWISE_XOR', 'ASSIGN_DIVIDE', 'ASSIGN_MULTIPLY', 'ASSIGN_REMAINDER', 'ASSIGN_SHIFT_LEFT', 'ASSIGN_SHIFT_RIGHT', 'ASSIGN_SUBTRACT', 'COLON', 'COMMA', 'DOT', 'LEFT_BRACE', 'LEFT_BRACKET', 'LEFT_PARENTHESIS', 'QUESTION', 'RIGHT_BRACE', 'RIGHT_BRACKET', 'RIGHT_PARENTHESIS', 'SEMICOLON', 'EXTENSION', 'VERSION', 'INCLUDE', 'FLOAT_LITERAL', 'IDENTIFIER', 'INT_LITERAL', 'STRING_LITERAL', 'END_OF_FILE'];\n\n  GLSLX.Exports.main();\n})();\n"],"sourceRoot":""}