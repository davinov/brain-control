<template>
  <div>
    <input
      type="range"
      v-model="k1"
      min="0"
      max="1"
      step="0.01"
    />
    <pre>{{ k1 }}</pre>
    <input
      type="range"
      v-model="k2"
      min="0"
      max="1"
      step="0.01"
    />
    <pre>{{ k2 }}</pre>
    <svg
      class="brain-visualization"
      :height="height"
      :width="width"
    >
      <g
        class="brain-wires"
        v-for="(wire, i) in brainWires()"
        :key="i"
      >
        <path
          v-for="(path, i) in wire"
          :key="i"
          class="brain-wire"
          :transform="originTranslation"
          :d="path"
        ></path>
      </g>
    </svg>
  </div>
</template>

<script lang="ts">
import { Component, Prop, Vue } from 'vue-property-decorator';
import { line, lineRadial, arc, curveCardinal, curveNatural, curveMonotoneX, curveBasis } from 'd3-shape';
import { interpolateString, interpolateNumber } from 'd3-interpolate';
import { easeQuadInOut, easeCubicOut, easeCubicIn, easeCubic, easeCircle } from 'd3-ease';

@Component
export default class Vizualisation extends Vue {
  k1: number = 1;
  k2: number = 1;

  @Prop({ default: 800 })
  height: number;

  @Prop({ default: 800 })
  width: number;

  get originTranslation () {
    return `translate(${this.width / 2}, ${this.height / 2})`;
  }

  brainWires () {
    return [0, 1/4, 1/2, 3/4, 1].map(y => this.brainWire(
      +this.k1 + easeCircle(y) * (+this.k2 - +this.k1)
    , y))
  }

  // A brain wire is made of two vertically symetric pathes
  brainWire (k: number, y: number) {
    let curve = line().curve(
      curveCardinal.tension(y)
    );

    return [
      curve(this.wirePoints(k, y))
    ,
      curve(
        this.wirePoints(k, y).map(this.horizontalSymetry).reverse()
      )
    ]
  }

  wirePoints (k: number, y: number) {
    return [
      this.leftPoint(k, y),
      this.leftMiddlePoint(k, y),
      this.middlePoint(k, y),
      this.rightMiddlePoint(k, y),
      this.rightPoint(k, y),
    ].map(this.verticalTranslation(- y * this.radius));
  }

  get radius () {
    return Math.sqrt(
      Math.pow((this.width / 2), 2) + Math.pow((this.height / 2), 2)
    ) / 2;
  }

  leftPoint (k: number, y: number): [number, number] {
    return [
      interpolateNumber(- this.width / 2, - this.radius)(easeCubicIn(k))
    ,
      interpolateNumber(0, this.radius)( y * k )
    ]
  }

  leftMiddlePoint (k: number, y: number): [number, number] {
    let circleOrSquareRatio = interpolateNumber(Math.SQRT2 / 2, 1);

    return [
      interpolateNumber(- this.width / 4, - this.radius * circleOrSquareRatio(y))(easeCubicIn(k))
    ,
      interpolateNumber(0, - this.radius * circleOrSquareRatio(y))(easeCubic(k)) + interpolateNumber(0, this.radius)( y * k )
    ]
  }

  middlePoint (k: number, y: number): [number, number] {
    return [
      0
    ,
      interpolateNumber(0, - this.radius)(easeCubicOut(k)) + interpolateNumber(0, this.radius)( y * k )
    ]
  }

  rightMiddlePoint (k: number, y: number): [number, number] {
    return this.verticalSymetry(this.leftMiddlePoint(k, y));
  }

  rightPoint (k: number, y: number): [number, number] {
    return this.verticalSymetry(this.leftPoint(k, y));
  }

  // Symetric against the vertical axis
  verticalSymetry (point: [number, number]): [number, number] {
    return [
      -point[0], point[1]
    ]
  }

  // Symetric against the horizontal axis
  horizontalSymetry (point: [number, number]): [number, number] {
    return [
      point[0], -point[1]
    ]
  }

  verticalTranslation (dy: number) {
    return function(point: [number, number]): [number, number] {
      return [
        point[0], dy + point[1]
      ]
    }
  }
}
</script>

<style scoped lang="scss">
.brain-visualization {
  background-color: black;
}

.brain-wire {
  stroke: white;
  stroke-width: 3px;
  fill: none;
}
</style>
